



# 计算机网络面试问题总结

## TCP和UDP

1. ###### TCP和UDP的区别

2. TCP的拥塞控制

3. 为什么是三个重复ACK才快重传

4. 三次握手和四次挥手

5. TIME_WAIT说一下

6. TCP三次握手对应的Socket变成的API说一下（？）

7. UDP对应的Socket编程API说一下（？）

8. TCP如何保证数据的有序

9. 使用UDP时如果想要保证可靠性，可以如何实现

10. TCP和UDP分别对应的应用层协议有哪些

11. 一台服务器最多能建立多少TCP连接

12. TCP首部有哪些 多少个字节？

13. UDP首部？

14. 网络带宽网速计算，10m带宽的实际下载速度？速度=带宽/8  10/8=1.25MB

15. 序列号是随机取的吗？

16. 每次都是客户端先发出fin包吗？（？）

17. TCP 粘包、拆包及解决方法？

18. TCP 长连接和短连接有什么区别？

19. 一个UDP连接可以复用已经被TCP连接占用的端口嘛？

## HTTP

1. http get post区别 post安全性体现在哪里（√）
2. dns协议底层是什么（√）
3. dns劫持（√）
4. Tcp和IP区别
5. 常见加密算法
6. 如何保证CA证书的真实性
7. http用的是tcp还是udp？（√）
8. 



# 并发多线程

## 什么是上下文切换？

[上下文]: https://blog.csdn.net/qq_41359051/article/details/89673188

## 创建线程为什么比较耗时？

- 必须为线程堆栈分配和初始化大量内存块。
- 需要进行系统调用，以便在主机OS中创建/注册本机线程。
- 描述符需要创建、初始化并添加到JVM内部数据结构中。

## 创建一个线程时，会在哪些区域分配内存？

程序计数器，虚拟机栈和本地方法栈

## java中线程间通信的方式

1. 同步 synchronized
2. while轮询
3. wait/notify机制
4. 管道通信   java.io.PipedInputStream 和 java.io.PipedOutputStream

## 对象头

Java对象保存在内存中时，由以下三部分组成：

> 1，对象头
>
> 2，实例数据
>
> 3，对齐填充字节

对象头由三部分组成

1，Mark Word

2，指向类的指针

3，数组长度（只有数组对象才有）



![image-20210518212159058](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210518212159058.png)

JDK1.6以后的版本在处理同步锁时存在锁升级的概念，JVM对于同步锁的处理是从偏向锁开始的，随着竞争越来越激烈，处理方式从偏向锁升级到轻量级锁，最终升级到重量级锁

## 偏向锁

> 经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。
> 引入的主要目的是，为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令

偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作

获取锁流程:

1. 检测Mark Word是否为可偏向状态，即是否为偏向锁==1==，锁标识位为==01==；
2. 若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤(5)，否则执行步骤(3)；
3. 如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程(4)；
4. 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；
5. 执行同步代码块

释放锁

偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争

## 轻量级锁

与偏向锁的区别是，引入偏向锁是假设同一个锁都是由同一线程多次获得，而轻量级锁是假设同一个锁是由n个线程交替获得

获取锁

1. 判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在==当前线程的栈帧==中建立一个名为==锁记录==（Lock Record）的空间，用于==存储锁对象目前的Mark Word的拷贝==（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；
2. JVM利用==CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针（地址，修改的是地址）==，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；
3. 判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；

释放锁轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：

1. 取出在获取轻量级锁保存在Displaced Mark Word中的数据；
2. 用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；
3. 如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。

### 整个锁升级的过程：

1. A线程想要获得锁，首先==判断对象头的锁标志==，如果是无锁（0 01）则==修改线程id==并运行同步方法块，如果是偏向锁（1 01）则跳转到2
2. 此时==检查对象头线程id是否是本线程==，如果是则直接执行同步方法块，如果不是执行3
3. 尝试使用CAS操作竞争锁，如果竞争成功则修改线程id并执行同步方法，如果没有成功则说明此时有竞争（假设此时线程B占有偏向锁），应该准备升级为轻量级锁
4. 当==线程B 执行到全局安全点==之后，将B挂起，并判断线程B的状态（是否退出同步方法块），如果是的话，那么A再执行3，不是的话执行5
5. 在线程B的栈中==分配锁记录==，同时==拷贝当前对象头的markword到锁记录==中，然后用CAS将markword指向所记录地址，同时==将对象头中的锁标识改为00==，然后唤醒B，从安全点开始继续执行
6. 此时A也执行B一样的操作，但是A对markword的CAS操作会失败（期望值是markword原本的值），==此时A开始自旋等待锁释放==（JDK1.6之前自旋10次，1.6之后自适应，由前一次在同一个锁上的自旋时间及锁的拥有者的状态），==若自旋结束后仍然没有获得锁，A升级为重量锁，并将对象头中的锁标识修改成10==，同时阻塞
7. 线程B在释放锁的时候，使用==cas将 存在线程栈中的拷贝信息替换回markword中==，如果成功则直接释放锁，如果失败，则说明markword被修改（改成了重量锁），此时释放锁的同时还要，唤醒A线程



[辅助理解文章1]: https://baijiahao.baidu.com/s?id=1669027594605610676&amp;wfr=spider&amp;for=pc
[辅助理解文章2]: https://blog.csdn.net/tongdanping/article/details/79647337



## Synchronized

### 说说自己对于synchronized关键字的了解

`synchronized` 关键字解决的是多个线程之间访问资源的同步性，`synchronized`关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行

### 怎么使用的？（可以修饰哪些内容，锁定的是什么）

**1.修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

```java
synchronized void method() {
  //业务代码
}Copy to clipboardErrorCopied
```

**2.修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。因为静态成员不属于任何一个实例对象，是类成员（ _static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份_）。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。

```java
synchronized static void method() {
//业务代码
}Copy to clipboardErrorCopied
```

**3.修饰代码块** ：指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

```java
synchronized(this) {
  //业务代码
}
synchronized(xx.class) {
  //业务代码
}
```

### 讲一下Synchronized的底层原理？

修饰同步语句块开头的情况

![image-20210516102502161](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210516102502161.png)

从上面我们可以看出：

**`synchronized` 同步语句块的实现使用的是 ==monitorenter== 和 ==monitorexit== 指令，其中 ==monitorenter== 指令指向同步代码块的开始位置，==monitorexit== 指令则指明同步代码块的结束位置。**

当执行 `monitorenter` 指令时，线程试图获取锁也就是获取 **对象监视器 `monitor`** 的持有权。

> 在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由[ObjectMonitor](https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp)实现的。每个对象中都内置了一个 `ObjectMonitor`对象。
>
> 另外，`wait/notify`等方法也依赖于`monitor`对象，这就是==为什么只有在同步的块或者方法中才能调用wait/notify等方法==，否则会抛出`java.lang.IllegalMonitorStateException`的异常的原因。

在执行`monitorenter`时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。

在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。



修饰方法的情况

![image-20210516102935640](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210516102935640.png)

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象


### Synchronized和ReentrantLock有什么区别？Lock有什么好处

1. 原始构成

   `Synchronized`是关键字，属于`jvm`层面  底层用`monitor`实现  `monitorenter`和`monitorexit`

   ` Lock`是具体类，属于API层面

2. 使用方法

   Synchronized 不需要用户手动释放锁 对应代码块执行完会自动释放

   ReentrantLock需要用户手动释放锁，否则可能产生死锁

3. 等待是否中断

   synchronized不可中断

   ReentrantLock可以中断,用lockInterruptibly()方法  可以被线程的.interrupt()方法中断   抛出异常

4. 加锁是否公平

   Synchronized非公平锁

   ReentrantLock都可以

5. ReentrantLock可以实现选择性通知  Conditon（精确唤醒）



卖票（没有交互）

生产者消费者（有交互 有通知）

## 虚假唤醒：

```java
/**
     * 虚假唤醒
     * 假设此刻number==1
     * 线程A 此时进入了第一个判断里面 但是没有执行wait这个时候系统调度
     * 此时线程B 执行因为number==1不会进入wait此时number--变成0 并调度到A
     * 此时A开始执行wait并释放了锁
     * 系统调度到线程C 因为number==0 C不会进入判断 并让number进行+1
     * 此时C唤醒A
     * A继续执行后面的代码 即number++ 此时number变成2  程序逻辑错误
     *
     * 解决方法：
     * 不能在if代码块中进行wait操作应该用while即被唤醒后应该再判断一次
     */
     while (number==1)
            this.wait();//会释放锁
```

## 8锁

知识点：

TimeUnit用来精确每个单位的时间控制

```java
 try {
	 TimeUnit.SECONDS.sleep(4);
 } catch (InterruptedException e) {
 	e.printStackTrace();
 } 
 
 枚举类
 SECONDS {
        public long toNanos(long d)   { return x(d, C3/C0, MAX/(C3/C0)); }
        public long toMicros(long d)  { return x(d, C3/C1, MAX/(C3/C1)); }
        public long toMillis(long d)  { return x(d, C3/C2, MAX/(C3/C2)); }
        public long toSeconds(long d) { return d; }
        public long toMinutes(long d) { return d/(C4/C3); }
        public long toHours(long d)   { return d/(C5/C3); }
        public long toDays(long d)    { return d/(C6/C3); }
        public long convert(long d, TimeUnit u) { return u.toSeconds(d); }
        int excessNanos(long d, long m) { return 0; }
 }

当一个线程获执行对象中的一个synchronized方法，则该对象中其它同步方法也不允许别的线程执行
静态就是类锁  普通就是对象锁  两个各自锁各自的
```

## 多线程集合不安全

### 1.List

```java
list.forEach(System.out::println);
```

多线程读写导致==java.util.ConcurrentModificationException==异常

解决方法有三个：

1.vector  直接加synchronized  保证了一致性但是性能差

2.Collections.synchronizedList(new ArrayList<>())

3.CopyOnWriteArrayList，是写时复制的将当前容器object[]进行复制 再在新容器进行添加操作  添加完成之后再通过setArray方法将原容器引用指向新容器    此时就实现了并发的读而不需要加锁 读和写不同的容器

```
public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);//复制数组 不够的用默认值填充
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
```

### 2.Set与Map

Set

1..Collections.synchronizedSet(new HashSet<>())

2.CopyOnWriteArraySet()（底层是CopyOnWriteArrayList）

HashSet底层是HashMap  

add(E e)  e是key  value是一个常量对象

```java
private static final Object PRESENT = new Object();
public boolean add(E e) {
        return map.put(e, PRESENT)==null;
}
```

Map

1..Collections.synchronizedMap(new HashMap<>())

2.new ConcurrentHashMap()

容量是16  负载因子0.75

底层是一个Node<Key,Value>

## 实现多线程的三种方法

### 1.继承Thread

```
public class MyThread extends Thread {
　　public void run() {
　　 System.out.println("MyThread.run()");
　　}
}

MyThread myThread1 = new MyThread();
MyThread myThread2 = new MyThread();
myThread1.start();
myThread2.start();
```

### 2.实现Runnable接口

如果自己的类已经extends另一个类，就无法直接extends Thread，此时，必须实现一个Runnable接口

```
public class MyThread extends OtherClass implements Runnable {
　　public void run() {
　　 System.out.println("MyThread.run()");
　　}
}
```

### 3.实现Callable接口

#### Callable接口与Runnable接口区别？

```
1.有无返回值
2.是否抛出异常
3.方法名字不一样run()  call()
```

```
class MyThread implements Runnable{
        @Override
        public void run() {

        }
    }

class  MyThread2 implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
    return null;
}
}
```

具体使用

```java
class  MyThread implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        System.out.println("come in here");
        TimeUnit.SECONDS.sleep(2);
        return 1024;
    }
}

public class CallableDemo {
    /**
     * 实现多线程的三种方法
     * 1.继承Thread
     * 2.实现Runnable接口
     * 3.实现Callable
     */

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask futureTask=new FutureTask(new MyThread());//实现了RunnableFuture接口  继承Runnable接口
        new Thread(futureTask,"A").start();
        new Thread(futureTask,"B").start();
        System.out.println(futureTask.get());//输出返回值  会阻塞等待线程完成才输出结果
        System.out.println("计算完成");

    }
}

输出结果： 
come in here
1024
计算完成
原因：
   都是用futureTask一个对象，开多个线程的时候一个线程完成另一个线程不会再做 
```

## JUC辅助类

### 1.CountDownLatch

如何保证线程按一定顺序执行，比如前6个线程执行完才能执行主线程

countDownLatch.==countDown()==;//计数器-1

countDownLatch.==await()==;//阻塞

```
public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch=new CountDownLatch(6);
        for (int i = 0; i <6 ; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"离开教室");
                countDownLatch.countDown();//计数器-1
            },String.valueOf(i)).start();
        }
        countDownLatch.await();//阻塞
        System.out.println("锁门");
    }
```

### 2.CyclicBarrier

上面那个是倒数  这个是累加

构造参数第二个参数时runnable接口  当数字达到7的时候会执行

```
 public static void main(String[] args) {
        CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()->{
            System.out.println("8");
        });
        for (int i = 0; i <7 ; i++) {
            final int tempint=i;
            new Thread(()->{
                try {
                    System.out.println(Thread.currentThread().getName()+"执行"+tempint);
                    cyclicBarrier.await();//会阻塞 并让+1
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }

            },String.valueOf(i)).start();
        }
    }
```

### 3.Semaphore

信号量控制

主要用于：控制共享资源的互斥使用以及并发线程数的控制

acquire:查询并获取信号量  -1，会阻塞

release:释放信号量+1，唤醒等待线程

==参数为1==的时候等价于在资源类上＋synchronize

```
  public static void main(String[] args) {
        Semaphore semaphore=new Semaphore(3);//假设三个资源
        for (int i = 0; i <6 ; i++) {
            new Thread(()->{
                try {
                    semaphore.acquire();//查询  阻塞
                    System.out.println(Thread.currentThread().getName()+"\t抢占了一个资源");
                    TimeUnit.SECONDS.sleep(3);
                    System.out.println("离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    semaphore.release();//释放资源
                }
            },String.valueOf(i)).start();
        }
    }
}
```

## 读写锁ReadWriteLock

```java
class MyCache{
    private volatile Map<String,Object> map=new HashMap<>();
    private ReadWriteLock readWriteLock=new ReentrantReadWriteLock();//重点代码
    public void get(String key) throws InterruptedException {
         readWriteLock.readLock().lock();//重点代码
          try {
              System.out.println(Thread.currentThread().getName()+"\t读取数据");
              TimeUnit.MILLISECONDS.sleep(300);
              Object result=map.get(key);
              System.out.println(Thread.currentThread().getName()+"\t读取成功"+result);
          }catch (InterruptedException e) {
              e.printStackTrace();
          } finally {
             readWriteLock.readLock().unlock();//重点代码
          }

    }

    public void put(String key,Object object) throws InterruptedException {
         readWriteLock.writeLock().lock();
          try {
              System.out.println(Thread.currentThread().getName()+"\t写入数据");
              TimeUnit.MILLISECONDS.sleep(300);
              map.put(key,object);
              System.out.println(Thread.currentThread().getName()+"\t写入完成");
          }catch (InterruptedException e) {
              e.printStackTrace();
          } finally {
             readWriteLock.writeLock().unlock();
          }

    }
}
/**
 *
 * 读 读共存
 * 读 写不可
 * 写 写不可
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache=new MyCache();
        for (int i = 0; i <5 ; i++) {
            final int temp=i;
            new Thread(()->{
                try {
                    myCache.put(temp+"",temp);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }

        for (int i = 0; i <5 ; i++) {
            final int temp=i;
            new Thread(()->{
                try {
                    myCache.get(temp+"");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

## 阻塞队列

队列是==空的==，获取元素操作阻塞

队列是==满的==，添加元素操作阻塞

![image-20210511154818459](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210511154818459.png)

| 方法类型 | 抛出异常  |  特殊值  |  阻塞  |        超时        |
| :------: | :-------: | :------: | :----: | :----------------: |
|   插入   |  add(e)   | offer(e) | put(e) | offer(e,time,unit) |
|   移除   | remove()  |  poll()  | take() |  poll(time,unit)   |
|   检查   | element() |  peek()  |        |                    |

| 抛出异常 | 当阻塞队列满时，再往队列add元素会抛出IllegalStateException:Queue full                                     当阻塞队列空时，再往队列remove元素会抛出NoSuchElementException |
| -------- | :----------------------------------------------------------- |
| 特殊值   | 插入方法，成功true失败false\|\|移除方法，成功返回出队列的元素，队列没有返回null |
| 一直阻塞 | 当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程知道put数据or响应中断退出\|\|当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用 |
| 超时退出 | 阻塞队列满时，队列会阻塞生产者线程一定时间，超过时间生产者线程会退出 |

==offer("a",3L,TimeUnit.SECONDS)==   3 s

## ThreadPool线程池

### 为什么要用线程池（有什么好处？）

1. 降低线程创建带来的消耗(复用已创建好的线程)
2. 提高响应速度（不需要等待线程创建）
3. 提高线程的可管理性

### API

主要用==ExecutorService==接口 实现类有三个

通过==Executors==工具类实现

主要两个方法 ==execute()==  ==shutdown()==

```java
 public static void main(String[] arg s) {
        //执行长期任务性能好，创建一个线程池，一池有n个固定的线程
        ExecutorService executorService= Executors.newFixedThreadPool(5);//有5个线程,类似一个银行有5个受理窗口
        ExecutorService executorService= Executors.newSingleThreadExecutor();//有1个线程,类似一个银行有1个受理窗口
        ExecutorService executorService= Executors.newCachedThreadPool();//有n// 个线程,类似一个银行有n个受理窗口
        try{
            for (int i = 0; i < 10; i++) {
                TimeUnit.SECONDS.sleep(2);
                //参数是Runnable
                executorService.execute(()->{
                    System.out.println(Thread.currentThread().getName()+"\t办理业务");
                });
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            executorService.shutdown();//关闭
        }
    }
```

### ThreadPoolExecutor

上面三个实现类源码都是return 一个ThreadPoolExecutor

```java
 public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

### 线程池的7个参数

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

| corePoolSize    | 线程池中的常住核心线程数                                     |
| --------------- | ------------------------------------------------------------ |
| maximumPoolSize | 线程池能够容纳的同时执行的最大线程数，必须大于等于1          |
| keepAliveTime   | 多余的空闲线程的存活时间，当前池中线程数量超过corePoolSize，当空闲时间达到keepAliveTime，多余线程会被销毁直到剩下corePoolSize |
| unit            | keepAliveTime的单位                                          |
| workQueue       | 任务队列，被提交但商未被执行的任务（比如五个线程 有个6个任务 那么有一个任务要进入这个队列） |
| threadFactory   | 线程工厂，用于创建线程 默认即可                              |
| handler         | 拒绝策略，表示当队列满了，并且工作线程 大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的Runnable的策略 |

### 线程池执行原理

使用者提交任务

线程池

1.判断==核心线程池==是否已经满了  没满 创建线程执行任务

2.满了 判断==阻塞队列==是否已经满了  没满  将任务放进阻塞队列

3.满了 判断==线程池线程数==是否满了  没满 创建线程执行任务

4.满了  根据==拒绝策略==处理不能执行的任务

![image-20210512154602550](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210512154602550.png)

 

### 在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？

都不用，用自己定义的

阿里巴巴JAVA开发手册

线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式

![image-20210512155627967](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210512155627967.png)

> 什么是OOM？ 
>
> OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError。看下关于的官方说明： Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector. 意思就是说，当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error（注：非exception，因为这个问题已经严重到不足以被应用处理）。

### 拒绝策略

1. AbortPolicy：直接抛出RejectedExecutionException异常
2. CallerRunsPolicy：”调用者运行“是 一种调节机制，该策略不会抛弃任务，也不抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量
3. DiscardPolicy：抛弃无法处理的任务，不抛出异常
4. DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中，尝试再次提交该任务

### 如何合理配置线程池数量 

1. cpu密集型  任务需要大量运算，而没有阻塞，cpu一直全速进行   一般公式：CPU核数+1个线程的线程池
2. IO密集型 并不是一直在执行任务，尽可能配置多的线程   cpu核数*2
3. IO密集型  该任务需要大量的IO，大部分线程会被阻塞  cpu核数/(1-阻塞系数)  阻塞系统：0.8~0.9

IO密集也就是比如代码中有和数据库交互的,进行IO的时候当前线程会被阻塞，所以线程创建的多的话就可以充分利用cpu

```
Runtime.getRuntime().availableProcessors();//获取当前运行计算机处理器数量
```

### 使用无界阻塞队列会怎样？

如果出现问题就会导致线程处理每个任务都需要等待很长的时间；
处理任务的速度慢，产生任务的速度快，而任务队列是没有边界的，就会导致队列变得越来越大，从而导致内存飙升，还可能导致OOM内存溢出

## 链式编程和流式计算

需要用lombok@Accessors(chain=true)

![image-20210512181422635](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210512181422635.png)

### 四大函数式接口

![image-20210512202335690](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210512202335690.png)

```java
list.stream()
                .filter(u->{return u.getId()%2==0;})
                .filter(u->{return u.getAge()>24;})
                .map(user -> {return user.getUserName().toUpperCase();})
                .sorted(((o1, o2) -> {return o2.compareTo(o1);}))
                .limit(1)
                .collect(Collectors.toList()).forEach(System.out::println);
```

## 异步回调

CompletableFuture    

==runAsync(Runnable)==

==supplyAsync(Supply)==

whenComplete(BIComsumer)

exceptionally(Function)

```java
/**
     * 异步回调
     */
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Void> completableFuture=CompletableFuture.runAsync(()->{
            System.out.println(Thread.currentThread().getName()+"没有返回");
        });

        CompletableFuture<Integer> completableFuture2=CompletableFuture.supplyAsync(()->{
            System.out.println(Thread.currentThread().getName()+"有返回");
            int i=1/0;
            return 1024;
        });
        completableFuture2.whenComplete((t,u)->{
            System.out.println(""+t);

        }).exceptionally(t->{
            System.out.println("错误"+t.getMessage());
            return 4444;
        }).get();
    }
```

## Volatile是什么？

提供轻量级的同步机制

1. 保证可见性
2. 不保证原子性
3. 禁止指令重排

### JMM（Java Memory Model JAVA内存模型）

![image-20210513162130834](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210513162130834.png)

1. **原子性** : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。`synchronized` 可以保证代码片段的原子性。
2. **可见性** ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。`volatile` 关键字可以保证共享变量的可见性。（直接从内存中读，而不是从自己工作内存中）
3. **有序性** ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile` 关键字可以禁止指令进行重排序优化。

### 对于synchronized可见性

- `synchronized`关键字的语义JMM有两个规定，保证其实现内存可见性：
- 线程解锁前，必须把共享变量的最新值刷新到主内存中；
- 线程加锁前，将清空工作内存中共享变量的值，从主内存中冲洗取值。

### 对于volatile可见性

- 当对volatile变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存
- 写操作会导致其他线程中的缓存无效

这样，其他线程使用缓存时，发现本地工作内存中此变量无效，便从主内存中获取，这样获取到的变量便是最新的值，实现了线程的可见性。

### number++

number++是线程不安全的（没有保证原子性）

分三个步骤

![image-20210513172404323](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210513172404323.png)

### 如何解决原子性问题呢？

1. synchronized  但是不用
2. 使用AtomicInteger原子类

```java
class MyData{
    volatile int number=0;
    AtomicInteger atomicInteger=new AtomicInteger();
    public void add(){
        number=60;
    }

    public void addPlusPlus(){
        number++;
    }

    public void addAtomic(){
        atomicInteger.getAndIncrement();//i++
    }
}
public class VolatileDemo {
    public static void main(String[] args) {
        //seeOkVolatile();
        MyData myData=new MyData();
        for (int i = 1; i <=10 ; i++) {
            new Thread(()->{
                for (int j = 1; j <=1000 ; j++) {
                    myData.addPlusPlus();
                    myData.addAtomic();
                }
            },String.valueOf(i)).start();
        }
        //默认存在两个线程  主线程以及后台gc线程
        while (Thread.activeCount()>2){
            Thread.yield();//让出线程权
        }
        System.out.println( Thread.currentThread().getName()+"\tValue:"+myData.number);
        System.out.println( Thread.currentThread().getName()+"\tValue:"+myData.atomicInteger);
    }

    //可见性
    private static void seeOkVolatile() {
        MyData myData=new MyData();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName()+"\tcome in");
            try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
           myData.add();
            System.out.println(Thread.currentThread().getName()+"finished"+myData.number);
        },"A").start();

        while (myData.number==0){}
        System.out.println("over now");
    }
}
```

### 有序性

![image-20210513202915606](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210513202915606.png)

指令的重排顺序取决于==数据依赖==

![image-20210513204614792](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210513204614792.png)



第一种：可能没有重排  那么线程2输出6

第二种：重排了，flag在前面  然后线程2获得cpu进入条件输出5

![image-20210513205157925](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210513205157925.png)

![image-20210513205212322](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210513205212322.png)

**工作内存与主内存同步延迟现象导致的可见性问题**

可以使用synchronized和volatile关键字

**对于指令重排导致的可见性问题和有序性问题**

可以利用volatile关键字解决，因为volatile的作用是禁止指令重排

### 什么时候会用到volatile？（多线程下DCL单例模式）

可能产生不只一个实例对象

![image-20210513213252382](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210513213252382.png)

会导致返回没有初始化的一个对象

==为什么使用DCL？==

```java
 1 public class Singleton {
 2     private static Singleton instance = null;
 3     public static Singleton getInstance() {
 4         if(null == instance) {                    // line A
 5             instance = new Singleton();        // line B
 6         }
 7         
 8         return instance;
 9         
10     }
11 }
```

两个线程并发调用Singleton.getInstance()，假设线程一先判断instance是否为null，即代码中line A进入到line B的位置。刚刚判断完毕后，JVM将CPU资源切换给线程二，由于线程一还没执行line B，所以instance仍然为空，因此线程二执行了new Singleton()操作。片刻之后，线程一被重新唤醒，它执行的仍然是new Singleton()操作

可以直接加synchronized，但是为了不让每次都进行同步准备，利用DCL就可以提高性能，但是指令重排有可能导致出错，具体看上面

## CAS

比较并交换

### 底层原理?

CAS全称为Compare-And-Swap 它是一条==cpu并发原语==

功能是判断某个内存上的值是否为期望值，是则更改为新的值，这个过程保证原子性

![image-20210514101638819](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210514101638819.png)

### AtomicInteger底层原理?(CAS知道吗如何实现的)

```java
atomicInteger.getAndIncrement();
```

```java
// setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();//获取unsafe
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset;//获取偏移地址
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;//可见性


	public final int getAndIncrement() {
        return unsafe.getAndAddInt(this, valueOffset, 1);
    }
//valueOffset  内存偏移量
```



1. Unsafe类是什么

是CAS的核心类，Java方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe相当于后门，基于该类可以直接操作特定内存的数据.Unsafe类存在于sun.misc包,他的内部方法操作可以像C指针一样直接操作内存

2. valueOffset 表示变量值在内存中的偏移地址
3. volatile 保证可见性



![image-20210514095243078](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210514095243078.png)

![image-20210514102102535](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210514102102535.png)

v1 atomicInteger对象

v2 内存偏移地址

v4增加量

compareAndSwapInt（）当对应内存地址是期望值的时候，修改对应内存的值  但是返回的是一开始获得的值因为是i++

**整体归纳回答:**

AtomicInteger 类主要利用 ==CAS (compare and swap)==+ ==volatile== 和==unsafe类的native== 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。

UnSafe 类的 objectFieldOffset() 方法是一个==本地方法==，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 **volatile** 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。最后在unsafe类的addAndInt方法里面利用CAS实现

为什么不用synchronized?

这样子更高效

### 缺点：

1. 循环时间长，开销大  CAS长时间不成功，会给**cpu**带来很大的开销
2. 只能保证**一个共享变量**的原子操作  （多个可以加锁解决）

![image-20210514111344488](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210514111344488.png)

​	CAS原语就是保证一个共享变量的原子性

3. **ABA**问题

### 手写自旋锁

```java
class SpinningLock{
    private AtomicReference<Thread> ref=new AtomicReference<>();

    public void lock(){
        Thread thread=Thread.currentThread();
        while (!ref.compareAndSet(null,thread)){
            //自旋
        }
    }

    public void unLock(){
        Thread thread=Thread.currentThread();
        ref.compareAndSet(thread,null);
    }
}
public class SpinningLockDemo {
    /**
     * 手写一个自旋锁
     */
     static volatile int count=0;

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService=new ThreadPoolExecutor(100,
                100,
                3L,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(10),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy());
        CountDownLatch countDownLatch=new CountDownLatch(100);
        SpinningLock spinningLock=new SpinningLock();
        for (int i = 1; i <=100 ; i++) {
           executorService.execute(()->{
               spinningLock.lock();
               count++;
               spinningLock.unLock();
               countDownLatch.countDown();
           });
        }
        countDownLatch.await();
        System.out.println(count);
        executorService.shutdown();
    }

}
```



## ABA

：线程1从内存取出A,线程2也从内存取出A，线程将A变成B并写回内存，又把B改回A写回内存，这时线程A又把A改成C写回内存，但这并不应该发生

![image-20210514153835353](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210514153835353.png)

### 原子引用

可以放入自定义类

```java
@NoArgsConstructor
@AllArgsConstructor
@Getter
class User1{
    String username;
    int age;
}
/**
 * 原子引用
 */
public class AtomicReferenceDemo {


    public static void main(String[] args) {
        User1 z3=new User1("z3",21);
        User1 li4=new User1("li4",25);
        AtomicReference<User1> atomicReference=new AtomicReference<>();
        atomicReference.set(z3);
        System.out.println(atomicReference.compareAndSet(z3, li4));
    }
}

```

### ABA问题解决

==AtomicStampedReference==

ABA问题出现及解决：

```java
public class ABADemo {
    static AtomicReference<Integer> atomicReference=new AtomicReference<>(100);
    static AtomicStampedReference<Integer> atomicStampedReference=new AtomicStampedReference<>(100,1);
    public static void main(String[] args) {
        System.out.println("---------ABA问题产生----------");
        new Thread(()->{
            atomicReference.compareAndSet(100,101);
            atomicReference.compareAndSet(101,100);
        },"A").start();

        new Thread(()->{
            //保证线程A执行一次ABA操作
            try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
            System.out.println(atomicReference.compareAndSet(100, 2020)+"\t"+atomicReference.get());
        },"B").start();

        System.out.println("---------ABA问题解决----------");

        try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
        new Thread(()->{
            int stamp=atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName()+"\t第一次版本号"+stamp);
            //暂停
            try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
            atomicStampedReference.compareAndSet(100,101,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);
            System.out.println(Thread.currentThread().getName()+"\t版本号"+atomicStampedReference.getStamp());
            atomicStampedReference.compareAndSet(101,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);
            System.out.println(Thread.currentThread().getName()+"\t版本号"+atomicStampedReference.getStamp());
            },"C").start();

        new Thread(()->{
            int stamp=atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName()+"\t第一次版本号"+stamp);
            //暂停
            try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
            boolean result=atomicStampedReference.compareAndSet(100,101,stamp,stamp+1);
            System.out.println(Thread.currentThread().getName()+"\t修改成功否"+result);
            System.out.println(Thread.currentThread().getName()+"\t最新值"+atomicStampedReference.getReference()+"\t最新版本号"+atomicStampedReference.getStamp());
        },"D").start();
    }
}
```

![image-20210514164204204](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210514164204204.png)

## 请编码一个ArrayList的不安全的案例并给出解决方案

==ConcurrentModificationException==    (五个常见异常)

```
public class ContainerNoSafeDemo {
    public static void main(String[] args) {
        List<String> list=new ArrayList<>();
        for (int i = 1; i <=10 ; i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```

具体的在上面的多线程不安全有

## 公平锁/非公平锁/可重入锁/递归锁/自旋锁 谈谈你的理解？请手写一个自旋锁

### 公平锁和非公平锁

公平锁：在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中

非公平锁：上来就尝试占有锁，如果尝试失败，就再采用类似公平锁的方式

==ReentranLock==的创建可以指定构造函数的Boolean类型来决定公平或不公平   ==默认不公平==

非公平锁==优点==在于吞吐量比公平锁的大

==Synchronized也是一种非公平锁==

**公平锁**：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。

- 优点：所有的线程都能得到资源，不会饿死在队列中。
- 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

**非公平锁**：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。

- 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
- 缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。



### 可重入锁（又名递归锁）

在外层使用锁之后，在内层仍然可以使用，并且不发生死锁

可重入就是说某个线程已经获得某个锁，可以再次获取锁而==不会出现死锁==

==ReentranLock==和==Synchronized==就是可重入锁

只要lock和unlock匹配   多少次lock都可以否则会发生死锁线程会一直卡着

代码解释不可重入用原子类

```java
public class UnreentrantLock {

    private AtomicReference<Thread> owner = new AtomicReference<Thread>();

    public void lock() {
        Thread current = Thread.currentThread();
        //这句是很经典的“自旋”语法，AtomicInteger中也有
        for (;;) {
            if (!owner.compareAndSet(null, current)) {
                return;
            }
        }
    }

    public void unlock() {
        Thread current = Thread.currentThread();
        owner.compareAndSet(current, null);
    }
}
```

作用：避免死锁

### 自旋锁

是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁

==好处==是减少线程上下文切换的消耗，提高并发

==缺点==是循环会消耗cpu

```java
public class SpinLockDemo {
    AtomicReference<Thread> atomicReference=new AtomicReference<>();

    public void myLock(){
        Thread thread=Thread.currentThread();
        while (!atomicReference.compareAndSet(null,thread)){

        }
        System.out.println(Thread.currentThread().getName()+"\t"+"get lock");
    }

    public void myUnLock(){
        Thread thread=Thread.currentThread();
        atomicReference.compareAndSet(thread,null);
        System.out.println(Thread.currentThread().getName()+"\t"+"unlock");
    }

    public static void main(String[] args) {
        SpinLockDemo spinLockDemo=new SpinLockDemo();
        new Thread(()->{
            spinLockDemo.myLock();
           try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }
           spinLockDemo.myUnLock();
        },"A").start();

        new Thread(()->{
            spinLockDemo.myLock();
            spinLockDemo.myUnLock();
        },"B").start();
    }
}
```

### 独占锁(写锁)和共享锁(读锁)

独占锁：该锁一次只能被一个线程持有        ReentrantLock和Synchronized都是

共享锁:该锁可以被多个线程持有  ReentrantReadWriteLock读锁时共享锁，写锁是独占锁

读写  写写  写读互斥

具体代码看上面读写锁

## CountDownLatch CyclicBarrier Semaphore用过吗？

答案在上面

## 阻塞队列知道吗？

为什么需要BlockingQueue？

不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程

上面有API具体情况

**SynchronousQueue**

是一个不存储元素的的BlockingQueue

每一个put必须等待一个take，否则不能继续put

### 用在哪里

1.生产者消费者模式

## 死锁编码及解决

```java
class HoldLockThread implements Runnable{
    private String lockA;
    private String lockB;

    public HoldLockThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA){
            System.out.println(Thread.currentThread().getName()+"\t自己持有:"+lockA+"\t尝试获得"+lockB);
            try { TimeUnit.SECONDS.sleep(2L); } catch (InterruptedException e) { e.printStackTrace(); }
            synchronized (lockB){
                System.out.println(Thread.currentThread().getName()+"\t获得"+lockB);
            }
        }
    }
}
/**
 * 死锁编码
 */
public class DeadLockDemo {
    public static void main(String[] args) {
        String lockA="lockA";
        String lockB="lockB";
        new Thread(new HoldLockThread(lockA,lockB),"A").start();
        new Thread(new HoldLockThread(lockB,lockA),"B").start();
    }
}
```

```
jps -l查看进程
jstack  进程号  查看异常
```

## AQS

### LockSupport类

用于创建锁和其他同步类的基本线程阻塞原语

每个线程都会有一个permit许可证

调用LockSupport.park()时  底层调用Unsafe类的native方法

```java
public static void park(){
	UNSAFE.park(false,0L);
}
```

permit默认是0，调用park()（阻塞）方法时，当前线程会阻塞，直到别的线程将当前线程的permit设置为1（唤醒）

可以先==unpark()==再==park()==

![image-20210517103330934](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210517103330934.png)

为什么可以先唤醒线程后阻塞线程？

为什么唤醒两次后阻塞线程，线程还是会阻塞？permit最多为1

### AQS理论

 是用来构建锁或者其他同步器组件的==重量级基础框架及整个JUC体系的基石==

通过内置的==FIFO队列==来完成资源==获取线程==的排队工作，并通过一个==int==类型变量（state）表示持有锁的状态

> AQS使用一个volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作
>
> 将每个要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改

AQS内部

```java
	private transient volatile Node head;

    
    private transient volatile Node tail;

    
    private volatile int state;
```

Node内部

有waitStatus成员变量，表示该线程的等待状态==volatile int waitStatus==

```java
static final class Node {
        //正在以共享的方式等待锁
        static final Node SHARED = new Node();
    	//正在以独占的方式独占锁
        static final Node EXCLUSIVE = null;

        //线程被取消了
        static final int CANCELLED =  1;
        //后继线程需要唤醒
        static final int SIGNAL    = -1;
        //等待condition唤醒
        static final int CONDITION = -2;
        //共享式同步状态获取将会无条件传播下去
        static final int  = -3;

        //初始为0  状态是上面几种
        volatile int waitStatus;
        //前置节点
        volatile Node prev;

        //后节点
        volatile Node next;

        //当前线程
        volatile Thread thread;
}
```

![image-20210517222933686](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210517222933686.png)

队头取出，队尾插入

### 源码解读

![image-20210517223729348](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210517223729348.png)

![image-20210517223855384](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210517223855384.png)

![image-20210517224155042](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210517224155042.png)

![image-20210517224305299](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210517224305299.png)

公平锁要判断队列是否有等待的线程，没有的话才枪战锁

方法源码如下

![image-20210517224331231](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210517224331231.png)

 ![image-20210517224941733](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210517224941733.png)

![image-20210517225119260](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210517225119260.png)

三个方法tryAcquire()  acquireQueued(addWaiter())   selfInterrupt()

==tryAcquire()方法代码==

```
final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();//获取state
            if (c == 0) {//如果没人占用  尝试获取锁  这里代码与非公平锁第一个判断一致
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
            //否则有人占用锁  看一下当前是不是自己占用锁  是的话进入  
            //这里体现了可重入锁  可以两次lock 
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            //尝试占用锁 失败 返回false
            return false;
        }
```

==addWaiter==

```java
private Node addWaiter(Node mode) {
    	//mode是对应的waitStatus
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {//不是第一个节点的话
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                //前尾部连到新节点
                pred.next = node;
                return node;//结束方法
            }
        }
    	//第一个节点进入这个方法，如果上面的cas失败也会进入这里
        enq(node);
        return node;
    }
```

==enq==

```java
private Node enq(final Node node) {
        for (;;) {//自旋写法
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))//第一个节点是一个空的node  内层函数期待null
                    tail = head;//此时头尾都指向一个node但不是null  然后再进行一次循环 哨兵节点
            } else {
                //t指向tail  tail指向了head
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
```

![image-20210518093411142](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210518093411142.png)

```java
final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();//如果返回的是哨兵
                if (p == head && tryAcquire(arg)) {//哨兵等于头(说明是队列第一个节点，这里可以理解为每次都顺手尝试获取锁)  再尝试获取  成功后进入代码块
                    
                    //此时需要清除队列中的线程
                    setHead(node);//设置被选中的线程为头结点  这个方法
                    p.next = null; // help GC  把一开始的头结点去除掉
                    failed = false;
                    return interrupted;
                }
                //这里才是重点代码
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    //阻塞并检查是否中断  返回false表示没有被中断跳出判断再次进入自旋锁  此时被唤醒 说明资源没被占用  自旋后再执行上面尝试获取锁
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

```java
final Node predecessor() throws NullPointerException {
            Node p = prev;//此节点的前一个节点
            if (p == null)
                throw new NullPointerException();
            else
                return p;
        }
```

```java
//这个方法进入第一次是修改哨兵节点的状态值  第二次是返回true让上层函数继续执行
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;//没修改过的话应该是0  拿到前驱节点的状态
        if (ws == Node.SIGNAL)//第二次进来的时候就是为-1  返回true
            /*
             *signal  等待被占用的资源释放 直接返回true
             * 
             */
            return true;
        if (ws > 0) {
            /*
             * 取消状态，如果前驱节点放弃了，那么找最近一个不是取消状态的节点
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);//修改前继节点状态为-1，表示他的后继节点需要被唤醒
        }
        return false;//返回false
    }
```

```java
//这里才是真正的开始等待并阻塞 
private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);//阻塞
        return Thread.interrupted();//测试是否中断
    }
```

主要流程图

![image-20210518093807085](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210518093807085.png)

==unlock==

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            //传入头节点
            unparkSuccessor(h);//唤醒需要唤醒的后继节点
        return true;
    }
    return false;
}
```

```java
 protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
     		//等于0 就设置为null
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
     		//不一定是0奥
            setState(c);
            return free;
        }
```

```java
private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
    int ws = node.waitStatus;
    if (ws < 0)//头节点再次设置为0
        compareAndSetWaitStatus(node, ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    //头节点的下一个节点就是第一个节点
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {//为空 或者取消
        s = null;
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    if (s != null)
        //唤醒等待线程
        LockSupport.unpark(s.thread);
}
```

### 请你说一下你对AQS原理的理解？

AQS，是一个用来构建锁和同步器的框架，它是用一个volatile修饰的int变量state来表示资源的占用状态，0表示没有线程占用，1表示有线程占用，当一个线程请求资源的时候，如果state为0则可以请求成功，并用CAS将state设置成1，当其他线程再次请求的时候，AQS则将需要等待的线程封装成一个节点Node放入一个CLH队列当中，并在多次尝试获取锁失败后用LockSupport的park（）方法进行阻塞，等待资源的释放，等待线程被唤醒unpark

### AQS底层用了模板方法模式

同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：

1. 使用者继承 `AbstractQueuedSynchronizer` 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）
2. 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

**AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：**

```java
isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
```

默认情况下，每个方法都抛出 `UnsupportedOperationException`

以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。

再以 `CountDownLatch` 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后` countDown()` 一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 `await()` 函数返回，继续后余动作

### 几个AQS实现的工具类

- **`Semaphore`(信号量)-允许多个线程同时访问：** `synchronized` 和 `ReentrantLock` 都是一次只允许一个线程访问某个资源，`Semaphore`(信号量)可以指定多个线程同时访问某个资源。
- **`CountDownLatch `（倒计时器）：** `CountDownLatch` 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。
- **`CyclicBarrier`(循环栅栏)：** `CyclicBarrier` 和 `CountDownLatch` 非常类似，它也可以实现线程间的技术等待，但是它的功能比 `CountDownLatch` 更加复杂和强大。主要应用场景和 `CountDownLatch` 类似。`CyclicBarrier` 的字面意思是可循环使用（`Cyclic`）的屏障（`Barrier`）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。`CyclicBarrier` 默认的构造方法是 `CyclicBarrier(int parties)`，其参数表示屏障拦截的线程数量，每个线程调用 `await()` 方法告诉 `CyclicBarrier` 我已经到达了屏障，然后当前线程被阻塞。

**用过CountDownLatch吗？什么场景下使用的？**

`CountDownLatch` 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 `CountDownLatch` 。具体场景是下面这样的：

我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。

为此我们定义了一个线程池和 count 为 6 的`CountDownLatch`对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用`CountDownLatch`对象的 `await()`方法，直到所有文件读取完之后，才会接着执行后面的逻辑。

伪代码是下面这样的：

```java
public class CountDownLatchExample1 {
  // 处理文件的数量
  private static final int threadCount = 6;

  public static void main(String[] args) throws InterruptedException {
    // 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）
    ExecutorService threadPool = Executors.newFixedThreadPool(10);
    final CountDownLatch countDownLatch = new CountDownLatch(threadCount);
    for (int i = 0; i < threadCount; i++) {
      final int threadnum = i;
      threadPool.execute(() -> {
        try {
          //处理文件的业务操作
          ......
        } catch (InterruptedException e) {
          e.printStackTrace();
        } finally {
          //表示一个文件已经被完成
          countDownLatch.countDown();
        }

      });
    }
    countDownLatch.await();
    threadPool.shutdown();
    System.out.println("finish");
  }

}
```

## ThreadLocal

### 作用

**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？** JDK 中提供的`ThreadLocal`类正是为了解决这样的问题。 **`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。**

**如果你创建了一个`ThreadLocal`变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是`ThreadLocal`变量名的由来。他们可以使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。**

### 源码

Thread类中有ThreadLocalMap对象字段

```java
ThreadLocal.ThreadLocalMap threadLocals = null;
```

而ThreadLocalMap是ThreadLocal的静态内部类

当ThreadLocal调用set方法时

```java
public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
```

```java
ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
```

根据当前线程获取它的threadLocalMap

然后key就是threadLocal，value则是自己设置的值

我们在同一个线程中声明了两个 `ThreadLocal` 对象的话,`ThreadLocalMap`的 key 就是 `ThreadLocal`对象，value 就是 `ThreadLocal` 对象调用`set`方法设置的值。

![ThreadLocal数据结构](https://snailclimb.gitee.io/javaguide/docs/java/multi-thread/images/threadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)

### 用法

用withInitial方法创建一个ThreadLocal对象，参数是一个供给型接口

```java
public static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier) {
    return new SuppliedThreadLocal<>(supplier);
}
```

创建例子(泛型，参数实际是传入一个默认值)

```java
private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyyMMdd HHmm"));
```

### 内存泄漏

`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用,而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，`ThreadLocalMap` 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 key 为 null 的记录。使用完 `ThreadLocal`方法后 最好手动调用`remove()`方法

弱引用:

> 如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
>
> 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

## 面试手写：

​	单例模式，
​	排序算法
​	生产者和消费者
​	死锁

# JVM

IDEA_JDK版本控制

![image-20210522155200255](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522155200255.png)

![image-20210522155227451](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522155227451.png)



## 整个体系结构

![image-20210519154911421](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210519154911421.png)

## 类装载器

![image-20210519155109037](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210519155109037.png)

![image-20210519155153233](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210519155153233.png)

### 加载器种类

rt.jar

JVM 中==内置了三个重要的 ClassLoader==，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/`==lib==目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载目录 `%JRE_HOME%/`==lib/ext==目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
3. **AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

==自定义ClassLoader==

自定义的话需要继承`java.lang.ClassLoader`

![image-20210519162332794](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210519162332794.png)

### 案例分析

写一个这样的类

![image-20210519162801859](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210519162801859.png)

运行会报错

从而引出双亲委派机制

### 双亲委派

==每一个类都有一个对应它的类加载器==。系统中的 ClassLoder 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会==首先判断当前类是否被加载过==。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求==委派该父类加载器==的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

![ClassLoader](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png)

1. 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
2. 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
4. 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

#### 沙箱安全机制

是由基于双亲委派机制上 采取的一种JVM的自我保护机制,假设你要写一个java.lang.String 的类,由于双亲委派机制的原理,此请求会先交给Bootstrap试图进行加载,但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类,有则优先加载rt.jar包中的类,因此就保证了java的运行机制不会被破坏

#### 好处

双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（==JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类==），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

## 程序计数器

程序计数器是一块较小的内存空间。**==字节码解释器==工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

**从上面的介绍中我们知道程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

如果执行的是一个native方法，那这个计数器是空的

注意：==程序计数器==是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

## 方法区

存储被加载的类的结构信息，例如运行时常量、字段和方法数据、构造函数和普通方法的字节码内容

别名叫做 **Non-Heap（非堆）**

在不同虚拟机实现不一样，永久代(1.7)和元空间(1.8)

### 元空间

1. 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是**直接内存**（本机内存），受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小
2. 元空间里面存放的是**类的元数据**，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了

**字符串常量池1.7移动到堆中，1.8则把永久代改为元空间**

### 常量池

#### 字节码文件常量池

一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含常量池表（包括字面量和符号引用）

为什么要？

![image-20210521174246417](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521174246417.png)

#### 运行时常量池（方法区）

![image-20210521175755252](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521175755252.png)

## 虚拟机栈

Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的（Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：==局部变量表==、==操作数栈==、==动态链接==、==方法返回地址==）

**局部变量表主要存放了编译期可知的==各种数据类==**（boolean、byte、char、short、int、float、long、double）、**==对象引用==**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）

==栈帧==实际上类似是==方法==

局部变量表

非静态方法 第一个放的应该是this

![image-20210519214759858](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210519214759858.png)

**Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。**

- **`StackOverFlowError`：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
- **`OutOfMemoryError`：** Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常异常。

### 写一段程序使得栈异常

递归调用自己

```java
public class A{

    public void method(){

        method();

    }

    public static void main(String[] args){

        new A().mehtod();

        }
}
```

## 堆

 **此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存**

结构上在1.7之前

1. 新生代（Young Generation）
2. 老生代（Old Generation）
3. 永久代（Permanent Generation）

1.8之后

1. 新生代（Young Generation）
2. 老生代（Old Generation）
3. 元空间

![image-20210519221559108](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210519221559108.png)

## 堆、栈、方法区结合理解

![image-20210519220115519](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210519220115519.png)

## 直接内存

![image-20210522093959456](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522093959456.png)

涉及到用户态和内核态，NIO非阻塞

## GC

![image-20210520153638757](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210520153638757.png)

### minorGC过程

1. eden、SurvivorFrom 复制到SurvivorTo，年龄+1
   首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC的时候会扫描Eden区和From区域,对这两个区域进行垃圾回收(如果有对象的年龄已经达到了老年的标准，则赋值到老年代区)，同时把在from的对象的年龄+1

2. 然后，清空Eden和SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to

3. SurvivorTo和 SurvivorFrom 互换
   最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中复制来复制去,如此交换==15次==(由JVM参数==MaxTenuringThreshold==决定这个参数默认是15)最终如果还是存活就存入到老年代

**更好理解**

1.首先，所有新创建对象放在eden区域，两个survivor区域开始为空

2.当新创建的对象将eden区域装满，一次minor GC 被触发

3.存活对象被移动到第一块survivor 区域（S0），不存活对象随着eden区域的清理而被删除

4.下一次minor GC ，eden区域和上次一样，存活对象被移动到survivor区域，不存活对象被清理删除，和上次不同的是，这次存活对象被移动到另一个survivor区域（S1）。另外，S0中上次minor GC的幸存对象，年龄+1，然后被一起移动到S1区域。一旦所有的幸存对象都被移动到S1，S0和eden区域都会被清理掉。注意此时S1区域有不同年龄的幸存对象
5.下一次minor GC，和之前的一轮一样。不同的是，这一次S0和S1变换了角色，存活的对象被移动到S0，上次幸存的对象年龄+1，eden和S1区域被清空

特殊情况：GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 **分配担保机制** 把新生代的对象提前转移到老年代中去

### 堆参数调优

![image-20210520161907921](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210520161907921.png)

![image-20210520163336525](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210520163336525.png)

#### 元空间参数调优

可以使用 ==-XX：MaxMetaspaceSize== 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小

> 当元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace`

#### 参数调优

-Xms   设置初始分配大小，默认为物理内存的1/64

-Xmx 最大分配内存，默认为物理内存的1/4

-XX:+PrintGCDetails 输出详细的GC处理日志

```java
public static void main(String[] args) {
        long maxMemory=Runtime.getRuntime().maxMemory();//返回Java虚拟机试图使用的最大内存量
        long totalMemory=Runtime.getRuntime().totalMemory();//返回Java虚拟机中的内存总量
        System.out.println("MAX_MEMORY="+maxMemory+"字节\t"+(maxMemory/(double)1024/1024+"MB"));
        System.out.println("TOTAL_MEMORY="+totalMemory+"字节\t"+(totalMemory/(double)1024/1024+"MB"));
    }
```

![image-20210520193650571](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210520193650571.png)

```java
MAX_MEMORY=1029177344字节	981.5MB
TOTAL_MEMORY=1029177344字节	981.5MB
Heap
 PSYoungGen      total 305664K, used 20971K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)
  eden space 262144K, 8% used [0x00000000eab00000,0x00000000ebf7afb8,0x00000000fab00000)
  from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)
  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)
 ParOldGen       total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000)
  object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000)
 Metaspace       used 3255K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 351K, capacity 388K, committed 512K, reserved 1048576K
```

堆：物理上是新生区和老年区组成

#### 应该怎么配？

初始和最大一样大，避免GC和应用程序争抢内存，峰值忽高忽低

### GC日志

```
[GC (Allocation Failure) [PSYoungGen: 254531K->41159K(305664K)] 254531K->101767K(1005056K), 0.0450700 secs] [Times: user=0.03 sys=0.06, real=0.07 secs] 
[GC (Allocation Failure) [PSYoungGen: 288625K->41095K(305664K)] 510831K->263310K(1005056K), 0.0251417 secs] [Times: user=0.05 sys=0.00, real=0.02 secs] 
[GC (Allocation Failure) [PSYoungGen: 213066K->696K(305664K)] 596879K->465308K(1005056K), 0.0511492 secs] [Times: user=0.14 sys=0.03, real=0.05 secs] 
[GC (Allocation Failure) [PSYoungGen: 696K->664K(305664K)] 465308K->465276K(1005056K), 0.0031411 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Allocation Failure) [PSYoungGen: 664K->0K(305664K)] [ParOldGen: 464612K->243030K(699392K)] 465276K->243030K(1005056K), [Metaspace: 3242K->3242K(1056768K)], 0.0527139 secs] [Times: user=0.09 sys=0.01, real=0.05 secs] 
[GC (Allocation Failure) --[PSYoungGen: 166767K->166767K(305664K)] 732996K->732996K(1005056K), 0.0023376 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Ergonomics) [PSYoungGen: 166767K->0K(305664K)] [ParOldGen: 566228K->162231K(699392K)] 732996K->162231K(1005056K), [Metaspace: 3242K->3242K(1056768K)], 0.0374526 secs] [Times: user=0.11 sys=0.00, real=0.04 secs] 
[GC (Allocation Failure) [PSYoungGen: 161599K->0K(262656K)] 647028K->485429K(962048K), 0.0024347 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 0K->0K(295936K)] 485429K->485429K(995328K), 0.0027824 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(295936K)] [ParOldGen: 485429K->485429K(699392K)] 485429K->485429K(995328K), [Metaspace: 3242K->3242K(1056768K)], 0.1247360 secs] [Times: user=0.09 sys=0.00, real=0.13 secs] 
[GC (Allocation Failure) [PSYoungGen: 0K->0K(293888K)] 485429K->485429K(993280K), 0.0018389 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(293888K)] [ParOldGen: 485429K->485409K(699392K)] 485429K->485409K(993280K), [Metaspace: 3242K->3242K(1056768K)], 0.3601803 secs] [Times: user=0.23 sys=0.00, real=0.36 secs] 
```

```
[GC（类型） (Allocation Failure分配失败)
[PSYoungGen: 254531K（ygc前内存占用）->41159K（ygc后内存占用）(305664K y总共内存大小)] 
（ygc前堆内存占用）254531K->101767K（ygc后堆内存占用）(1005056K)（堆总大小）, 0.0450700 secs（ygc耗时）] 
[Times: user=0.03（用户耗时） sys=0.06（系统耗时）, real=0.07 secs（实际耗时）] 
```



### 异常（写一个程序使得堆溢出）

`java.lang.OutOfMemoryError:Java heap space`

设置大小为10m

直接new byte[40\*1024\*1024]  就可以出现异常了

```java
String str="qqq";
        while (true){
            str+=str+new Random().nextInt(88888888)+new Random().nextInt(999999999);
```

### 如何判断对象是否存活？

#### 1.引用计数法

每个对象有一个引用计数

缺点：

1. 每次对对象赋值需要维护一个引用计数器
2. 难以处理==循环引用==

![image-20210520204404906](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210520204404906.png)

A实例指向B，B指向A   然后了令AB值为null   这个时候因为都有引用 无法gc这两个null值

![image-20210522203957654](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522203957654.png)

#### 2.可达性分析算法（根搜索算法、追踪性垃圾收集）

GC Roots 根集合是一组必须活跃的引用

![image-20210521145924481](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521145924481.png)

#### GC Roots包括什么?

- 虚拟机栈(栈帧中的局部变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象
- Java虚拟机内部的对象：一些常住的异常对象 NullPointerException\OOM,系统类加载器

除了这些固定的GC Roots集合以外，根据用户选用的垃圾收集器以及当前回收的内存区域的不同，还可以有其他对象“临时性”地加入，共同构造完整GCRoot集合，比如分代收集和局部回收（比如只针对新生代进行GC，可以把一些老年代的对象作为GCRoots）

如果要使用可达性算法判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行

所以这也是GC时候  必须“Stop The World”的一个重要原因

即使是几乎不会发生停顿的CMS收集器，枚举根节点也要停顿

![image-20210521162220883](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521162220883.png)

### 如何判断一个常量是废弃常量？

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了

### 如何判断一个类是无用的类？

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收

### GC四大算法

#### 1.复制算法

==年轻代==中使用的是Minor GC，这种GC算法采用的是复制算法

tenure   [ˈtenjə(r)] 任期

threshold【θreʃhəʊld】n.门槛; 门口; 阈; 界; 起始点; 开端; 起点; 入门;

> MinorGC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，也即一旦收集后，Eden是就变成空的了。
>
> 当对象在Eden(包括一个Survivor区域，这里假设是from区域)出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳(上面已经假设为from区域，这里应为to区域，即to区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象)，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域(即to区域)中
>
> 然后清理所使用过的Eden 以及Survivor区域(即from 区域)，并且将这些对象的年龄设置为1，以后对象在Survivor 区每熬过一次 Minor GC，就将对象的年龄+1，当对象的年龄达到某个值时(默认是 **15**岁， 通过-XX:MaxTenuringThreshold 来设定参数)，这些对象
> 就会成为老年代。
>
>  -XX:MaxTenuringThreshold一设置对象在新生代中存活的次数

复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外复制到另外一块上面

==优点==：复制算法不会产生内存碎片

==缺点==：

1. 浪费了一半的内存
2. 如果对象的**存活率**很高，那么会需要复制很多对象，复制这一工作花费的时间，在存活率达到一定程度时变得不可忽略

#### 2.标记清除（mark-sweep）

老年代一般由标记清除或者是标记标记清除与标记整理的混合实现

分两步：

先标记出要回收的对象，然后统一回收这些对象

优点：

1. 不需要额外空间

缺点

1. 两次扫描，耗时严重
2. 会产生内存碎片（JVM要维护一个空闲内存列表）

#### 3.标记压缩（标记整理）

步骤：

1. 标记（和上面一样）

2. 压缩（compact）

   再次扫描，并往一端滑动存活对象

优点：没有内存碎片

缺点：需要移动对象的成本

#### 实际使用

一般使用标记清除，进行多次GC以后才使用标志压缩

#### 4.分代收集算法

==年轻代==特点是区域相对老年代较小，对象存活率低，用复制算法（可以使得需要复制的对象少）

==老年代==区域大，对像存活率高，复制算法明显不适合，用标志清除或者标志清除与整理结合

#### 5.增量收集算法

![image-20210521163544836](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521163544836.png)

缺点：

​		多了线程切换和上下文转换的消耗，造成系统吞吐量的下降

#### 6.分区算法

![image-20210521164622320](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521164622320.png)



#### HotSpot 为什么要分为新生代和老年代？

根据特点，提升效率

### Minor GC与Full GC分别在什么时候发生?

Minor GC：Eden区域满了，或者新创建的对象大小 > Eden所剩空间

Full GC：是清理整个堆空间—包括年轻代和永久代，时刻看下图（取决于ygc平均晋升大小）

![image-20210521225519133](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521225519133.png)

### 7种GC垃圾收集器

#### GC性能指标

![image-20210522225631938](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522225631938.png)

![image-20210522230242838](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522230242838.png)

![image-20210522232339077](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522232339077.png)

![image-20210523093618420](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523093618420.png)

#### 组合关系

![image-20210523093748677](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523093748677.png)

#### 查看对应回收器信息

```
-XX:+PrintCommandLineFlags
jinfo -flag UsexxxGC threadId 
```



#### Serial和SerialOld垃圾回收器

![image-20210523095248174](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523095248174.png)



![image-20210523095513880](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523095513880.png)

##### **优势：**

简单高效（针对单核cpu），没有线程切换的开销

##### **参数：**

指定使用Serial一组

```
-XX:+UseSerialGC
```

#### ParNew垃圾回收器

![image-20210523101651737](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523101651737.png)

![image-20210523101859425](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523101859425.png)

##### **参数：**

```
-XX:+UseParNewGC
-XX:ParallelGCThreads 限制并发线程数量
```

#### Parallel Scavenge回收器和Paraller Old：吞吐量优先

![image-20210523102846415](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523102846415.png)

![image-20210523102911329](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523102911329.png)

![image-20210523103307227](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523103307227.png)

##### **参数：**

![image-20210523103710381](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523103710381.png)

![image-20210523104526629](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523104526629.png)

设置的是N的值

![image-20210523105026807](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523105026807.png)

#### CMS回收器：低延迟

![image-20210523105830072](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523105830072.png)



##### **垃圾回收过程：**

![image-20210523110525821](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523110525821.png)

![image-20210523115832878](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523115832878.png)

![image-20210523120030759](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523120030759.png)

## ![image-20210523120419495](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523120419495.png)

![image-20210523120934704](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523120934704.png)

##### **弊端：**

![image-20210523121413676](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523121413676.png)

##### **参数：**

![image-20210523171557218](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523171557218.png)

![image-20210523172113076](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523172113076.png)

#### G1垃圾回收器（软实时）

##### 概念

![image-20210523173624430](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523173624430.png)

![image-20210523174415793](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523174415793.png)

![image-20210523174919727](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523174919727.png)

分区但是不连续了

![image-20210523175023087](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523175023087.png)

![image-20210523175640951](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523175640951.png)

![image-20210523181302181](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523181302181.png)

##### **参数：**

![image-20210523182648225](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523182648225.png)

![image-20210523182827185](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523182827185.png)

##### 使用场景：

![image-20210523200709613](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523200709613.png)

##### Region详细

![image-20210523201517698](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523201517698.png)

设置H原因

![image-20210523201652442](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523201652442.png)

##### 垃圾回收过程

![image-20210523203007577](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523203007577.png)

![image-20210523203440885](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523203440885.png)

##### Rememberd Set

![image-20210523204104911](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523204104911.png)

GCRoot会加入记忆集里的引用

![image-20210523204137857](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523204137857.png)

##### 步骤一：年轻代GC

![image-20210523210030783](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523210030783.png)

详细过程，理解就行  RSet不是直接在引用的时候更细，而是先加入一个==dirty card queue==（存储该对象直接引用的对象）中 最后统一更新Rset

避免因为线程同步的开销

![image-20210523210007560](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523210007560.png)

##### 步骤二：并发标记

![image-20210523210522605](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523210522605.png)

与CMS对比其实只是多了2和5

![image-20210523211056387](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523211056387.png)

##### 步骤三：混合回收

![image-20210523211604301](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523211604301.png)

可能步骤四：Full GC

![image-20210523211856510](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523211856510.png)

### 对象的finalization机制

![image-20210521170331079](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521170331079.png)

![image-20210521170350907](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521170350907.png)

![image-20210521170739514](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521170739514.png)

可能会问有哪几种状态？

![image-20210521171220038](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521171220038.png)

### 可达性分析后发现一个对象不再引用链上，它一定会被回收吗？

不一定，对象存在三种状态····

![image-20210521172006658](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521172006658.png)



### 对象的实例化

1. new
2. Class的newInsatnce   反射的方式，只能调用空参的构造器  权限必须是public
3. Constructor的newInsatnce(Xxx) 和上面一样，但是没有权限要求
4. clone():当前类需要实现Cloneable接口，实习clone()
5. 反序列化:通过对象的二进制流

查看字节码文件

![image-20210521195311473](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521195311473.png)

![image-20210521195335025](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521195335025.png)

```
javap -v -p MyObj.class
```

### 对象创建步骤

#### 1.判断对象对应的类是否加载、链接、初始化

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数==是否能在常量池中定位到这个类的符号引用==，并且==检查这个符号引用代表的类是否已被加载过、解析和初始化过==。如果没有，那必须==先执行相应的类加载过程==

#### 2.初始化内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定

分配方式分两种：

1.指针碰撞

![image-20210521203400377](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521203400377.png)

2.空闲列表分配

![image-20210521203533581](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521203533581.png)

 CMS会用

#### 3.线程并发安全（创建对象的时候堆内存是共享的）

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### **TLAB**是什么？作用？:

Thread Local Allocation Buffer，即线程本地分配缓存区，在创建对象分配内存的时候起作用

#### 4.初始化分配到的内存

设置属性默认值，保证对象实例字段在不赋值时可以直接使用

#### 5.设置对象的对象头

例如这个对象是哪个类的实例、如何才能找到类的**元数据信息**、**对象的HashCode**、**对象的 GC 分代年龄**、**对象的锁信息**等信息。 **这些信息存放在对象头中**

#### 6.执行init方法进行初始化

![image-20210521205941695](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521205941695.png)

```java
public class Person{

	private int id=441781;//属性默认初始化

	private int a;	

	private int c;

	{

		a=1;//代码块初始化

	}

	public Person(){

		c=1;//构造函数初始化

	}

init方法便是执行这三个初始化

}
```

### 对象的内存布局

由**对象头**、**实例数据**、**对齐填充**组成

对象头：

	1. **运行时元数据**（markword）：**哈希值**、**GC分代年龄**、**锁信息**
	2. **类型指针**：指向元数据的InsatnceKlass，确定该对象的类型
	3. 如果是数组，还需要记录数组长度

实例数据：

​	**是对象真正存储的有效信息**，包括在程序中所定义的各种类型的字段内容（包括从父类继承下来的）

​	通常是父类的变量出现在子类之前

对齐填充：

​	不是必须的，占位符

```java
下面的图对应这串代码
public static void main(String args[]){
	Customer cust=new Customer();
}
```

![image-20210521212946006](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521212946006.png)

### 对象的访问定位

JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？

![image-20210521214153294](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521214153294.png)

通过栈帧中局部变量表中的引用

访问的两种方式

1. 句柄

![image-20210521214348108](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521214348108.png)

好处：

![image-20210521223018609](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521223018609.png)

2. 直接指针（hotspot）

![image-20210521214457318](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210521214457318.png)

### 模拟问题

#### 对象在JVM是怎么存储的？

#### 对象头信息有什么？

## String类和常量池

String在JDK1.8内部是final char[]组成

1.9之后变成了byte[]

因为一个char占用两个字节，但是调查发现很大一部分字符串存的是拉丁文，而拉丁文只需要一个字节就能表示，所以1.9改成用byte存储，像中文则还是用两个byte存储，有一个encoding-flag标识

字符串常量池实际上是HashTable，用此保证常量池的唯一，有个默认长度1009（1.6）60013（7）

8的时候最小1009

不同长度对String的效率会有影响（数组+链表）

可以用-XX:StringTableSize修改

为什么要从永久代变成元空间？

1. 永久代的内存比较小
2. 元空间使用的是直接内存，受本地内存管理

![image-20210522103506693](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522103506693.png)

### **String 对象的两种创建方式**

```java
String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；
String str2 = new String("abcd");//堆中创建一个新的对象
String str3 = new String("abcd");//堆中创建一个新的对象
System.out.println(str1==str2);//false
System.out.println(str2==str3);//false
```

- 第一种方式是在常量池中拿对象；
- 第二种方式是直接在堆内存空间创建一个新的对象。

记住一点：**只要使用 new 方法，便需要创建新的对象。**

![String-Pool-Java](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/2019-3String-Pool-Java1-450x249.png)

### **字符串拼接**

![image-20210522112110968](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522112110968.png)

编译期优化就是，编译的时候会把两个""+""的内容先拼在一起  之后再进行导入

注意：一定要是==变量==拼接（哪怕是只有一个）才是创建新对象，如果是==常量==（final）则还是在常量池

```java
String str1 = "str";
String str2 = "ing";

String str3 = "str" + "ing";//常量池中的对象
String str4 = str1 + str2; //在堆上创建的新的对象
String str5 = "string";//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```

![字符串拼接](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-%E5%B8%B8%E9%87%8F%E6%B1%A02.png)

要尽量避免多个字符串拼接，会重新创建==字符串对象==（在堆空间）

拼接底层原理：

![image-20210522144624785](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522144624785.png)

#### 拼接操作尽量用StringBuilder的append()方法

1. 因为正常拼接要创建一个sb对象以及一个str对象

   但是直接用sb就是只有一个对象

2. 第一种方法会在堆里创建大量没有用的sb和str导致gc



### String s1=new String("abc")创建几个字符串对象？

**将创建 1 或 2 个字符串。**

如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”

如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象

通过看字节码可以看出来

new和ldc

![image-20210522153756528](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522153756528.png)

### String str=new String("1")+new String("b")?

![image-20210522154343389](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522154343389.png)

 sb的toString()方法不会在常量池创建对应的对象

查看字节码文件即可

String str = "abc" + "def";   创建一个因为都是常量

### Intern()方法

判断字符串常量值是否有对应值的存在，不存在则放入常量池中，存在则直接返回常量池的引用

![image-20210522155410674](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522155410674.png)

new String("1")在常量池创建了1

new + new  没有在常量池创建11

在jdk6可以理解为创了一个新对象

但是jdk7/8的时候，因为对象和字符串常量池都在堆中，为了节省空间将常量池中"11"直接指向new的那个对象（而不是放值）所以会出现true

![image-20210522161314158](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522161314158.png)

![image-20210522161900996](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522161900996.png)

#### 空间效率

![image-20210522164436129](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522164436129.png)

会更高，如果程序中会存在大量一样的字符串的话可以用intern

## 内存溢出和内存泄漏的区别？

### 内存溢出（OOM）

没有空闲内存

### 内存泄漏

对象不再被程序用到，但是GC又不能回收他们的情况

![image-20210522204205607](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522204205607.png)

## 安全点和安全区域

### 如何在gc发生时，检查所有线程都跑到最近的安全点停顿下来？

![image-20210522210044446](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522210044446.png)

### 安全区域

### ![image-20210522210430605](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522210430605.png)

## 强引用、软引用、弱引用（weak）、虚引用（Phantom）是什么？应用场景？

![image-20210522211646155](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522211646155.png)

![image-20210522213024677](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522213024677.png)

![image-20210522213741231](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522213741231.png)

软引用和弱引用往往和缓存有关

weakHashMap底部的entry就是弱引用

![image-20210522220614325](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210522220614325.png)

# MYSQL

## SQL执行过程、性能分析

### MYSQL包括哪些组件？

![image-20201227145728389](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201227145728389.png)

连接器、查询缓存、分析器、优化器、执行器（Server‘层）+存储引擎（MyIsam、Meomory、InnoDB）

#### 连接器

负责跟客户端建立连接、获取权限、维持和管理连接

**连接命令**

```
msyql -h ip -P port -u user -p 
```

如果一致，则连接器回到权限表中查找对应用户拥有的权限，之后这个连接要用到的权限逻辑判断都将基于这个时候读取到的权限，也就是说一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置

##### **数据库长连接与短连接**

数据库里面，==长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。==

==短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。==

建立连接的过程是复杂的，要尽量减少连接的建立，所以应该尽量使用长连接

但是如果全部使用长连接会有问题，会使得mysql占用内存变多，原因是mysql在执行过程中**临时使用的内存**是管理在**连接对象里面**的

#### 查询缓存

当mysql拿到一个查询请求之后，会先到查询缓存查看是否执行过这条查询语句。之前执行过的语句以及结果可能会议Key-Value的形式被直接缓存到内存中

如果语句不在查询缓存中的话，会执行后面的操作，执行完成后，执行结果会被存入查询缓存中。

##### 为什么不推荐使用查询缓存功能？

但是查询缓存的失效很频繁，不建议使用，只要有一个表进行了更新操作，这个表上的查询缓存都会被清空

需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了

#### 分析器

如果没有命中查询缓存，就会执行到这一步

分析器首先做词法分析，它需要将关键字（比如select）、表名、列名识别出来（==也就是在这个阶段检查语句中的表和列是否存在==），在这些操作之后就是语法分析，他会用mysql的语法规则来判断这个语法是否符合mysql语法

如果你的语句不对你就会收到

```
You have an error in your SQL syntax
```

#### 优化器

经过了词法分析和语法分析，就来到了优化器

优化器是在表里面有**多个索引的时候，决定使用哪个索引**；或者在一个语句有多表关联（join）的时候，决定**各个表的连接顺序**。

还有查询条件的顺序，调整使得满足索引的位置，比如你执行下面这样的语句，这个语句是执行两个表的join：

```
select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

- 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。
- 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。

这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案

#### 执行器

在**执行之前会检查你是否有权限**（如果命中查询缓存，**会在查询缓存放回结果的时候，做权限验证**。查询也会在优化器之前调用precheck验证权限）

**那为什么对权限的检查不在优化器之前做？**

有些时候，SQL语句要操作的表不只是SQL字面上那些。比如如果有个触发器，得在执行器阶段（过程中）才能确定。优化器阶段前是无能为力的

### 查询SQL的执行过程？（答执行那部分）

```mysql
select * from T where ID=10;
```

- 连接器连接、看查询缓存key与语句是否匹配（mysql8.0以前）
- 分析器进行词法分析（提取关键字、表名、字段名 检查表是否存在）、语法分析
- 优化器（索引的选择、where条件的顺序调整以及join连接表的顺序）
- 执行器

1. 检查是否有权限
2. 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
3. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
4. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端

### 更新SQL的执行过程

![img](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的binlog，并把binlog写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

### 两阶段提交

通过保证两个日志的一致来保证数据的一致性

**不采用的话**

1. **先写redo log后写binlog**。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。
   但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。
   然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。
2. **先写binlog后写redo log**。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。

#### 两阶段提交存在的问题

在多个事务并发的情况下，会造成写binglog与redolog提交顺序不一致的情况

```text
T1 (--prepare--binlog---------------------commit)
T2 (-----prepare-----binlog----commit)
T3 (--------prepare-------binlog------commit)
```

解析：

redo log prepare的顺序：T1 --》T2 --》T3

binlog的写入顺序：T1 --》 T2 --》T3

redo log commit的顺序：T2 --》 T3 --》T1

结论：由于binlog写入的顺序和redo log提交结束的顺序不一致，导致binlog和redo log所记录的事务提交结束的顺序不一样，最终导致的结果就是主从数据不一致（**会导致carsh safe和备库的时候数据一致性问题**）

因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。所以在早期的MySQL版本中，通过使用**prepare_commit_mutex**锁来保证事务提交的顺序，在一个事务获取到锁时才能进入prepare，一直到commit结束才能释放锁，下个事务才可以继续进行prepare操作

**降低了并发度**

### 组提交

**针对通过在两阶段提交中加锁控制事务提交顺序这种实现方式遇到的性能瓶颈问题，有没有更好的解决方案呢？**

![img](https://pic4.zhimg.com/80/v2-c7247995ff5416d0ece310e73d1f77b7_720w.jpg)

- 多个并发需要提交的事务共享一次fsync操作来进行数据的持久化

过程：

**第一阶段（prepare阶段）：**

持有prepare_commit_mutex，并且write/fsync redo log到磁盘，设置为prepared状态，完成后就释放prepare_commit_mutex，binlog不作任何操作。

**第二个阶段（commit阶段）**：这里拆分成了三步，每一步的任务分配给一个专门的线程处理：

1. **Flush Stage（写入binlog缓存）**
   ① 持有Lock_log mutex [leader持有，follower等待]
   ② 获取队列中的一组binlog(队列中的所有事务)
   ③ 写入binlog缓存
2. **Sync Stage（将binlog落盘）**
   ①释放Lock_log mutex，持有Lock_sync mutex[leader持有，follower等待]
   ②将一组binlog落盘（fsync动作，最耗时，假设sync_binlog为1）。
3. **Commit Stage（InnoDB commit，清楚undo信息）**
   ①释放Lock_sync mutex，持有Lock_commit mutex[leader持有，follower等待]
   ② 遍历队列中的事务，逐一进行InnoDB commit
   ③ 释放Lock_commit mutex

队列第一个事务为leader、其他事务为follower

好处：减小锁粒度，减少fsync次数（整组刷盘）

### 数据恢复过程（如何保证数据不丢失）

![img](https://pic4.zhimg.com/80/v2-c4a8f9208c72caab151abb1bdd889f7f_720w.jpg)

对上图进行简单描述就是：奔溃重启后会检查redo log中是完整并且处于prepare状态的事务，然后根据XID（事务ID），从binlog中找到对应的事务，如果找不到，则回滚；找到并且事务完整则重新commit redo log，完成事务的提交

1. **时刻A**（刚在内存中更改完数据页，还没有开始写redo log的时候奔溃）：
   因为内存中的脏页还没刷盘，也没有写redo log和binlog，即这个事务还没有开始提交，所以奔溃恢复跟该事务没有关系；
2. **时刻B**（正在写redo log或者已经写完redo log并且落盘后，处于prepare状态，还没有开始写binlog的时候奔溃）：
   恢复后会判断redo log的事务是不是完整的，如果不是则根据undo log回滚；如果是完整的并且是prepare状态，则进一步判断对应的事务binlog是不是完整的，如果不完整则一样根据undo log进行回滚；
3. **时刻C**（正在写binlog或者已经写完binlog并且落盘了，还没有开始commit redo log的时候奔溃）：
   恢复后会跟时刻B一样，先检查redo log中是完整并且处于prepare状态的事务，然后判断对应的事务binlog是不是完整的，如果不完整则一样根据undo log回滚，完整则重新commit redo log；
4. **时刻D**（正在commit redo log或者事务已经提交完的时候，还没有反馈成功给客户端的时候奔溃）：
   恢复后跟时刻C基本一样，都会对照redo log和binlog的事务完整性，来确认是回滚还是重新提交。

### 如何查看SQL的执行情况？

```mysql
mysql> explain select * from servers;
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | servers | ALL  | NULL          | NULL | NULL    | NULL |    1 | NULL  |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
row in set (0.03 sec)
```

key：用到的索引

rows：查询行数，该行数时统计信息估算出来的，不准确

### 如何在MYSQL中查找效率慢的SQL语句？

利用慢查询

几个变量参数

```
slow_query_log 表示是否开启慢查询 

long_query_time 设置超过多少秒归为慢查询

slow_query_log_file 查看慢查询日志
```



- **查看慢SQL是否启用**，查看命令：**show variables like 'slow_query_log'**; 

  如果结果为ON则是开启了，如果为OFF则表示禁用了。

- **开启慢查询命令**：**set global slow_query_log = on**;   

- **查看慢查询参数**，即设置超过多少秒的查询归为了慢查询。参数为：long_query_time，查询命令： show global variables like 'long_query_time';

  mysql默认时间为10秒，即10秒及以上的查询被归为了慢查询。我们的实际项目中根本就不可能这么包容你，所以得提供查询效率优化sql，让程序更快的执行。

- 这里设置时间为1秒，即超过1秒就会被认为慢查询。设置命令：**set global long_query_time =1**;用命令设置的，会立即生效，不用重启mysql服务。但重启mysql服务后就会失效。

- **查看设置的时间**， **show global variables like 'long_query_time'**;即可看到现在已经变为1秒了

- **查看慢查询存放日志**，命令： **show variables like 'slow_query_log_file'**;

  去相应目录下查看即可。

## 三个核心日志

### WAL是什么？

Write-Ahead Logging（写前日志），先写日志，再写磁盘

虽然日志也是写磁盘，但是写日志时顺序写，而写磁盘是随机IO写

##### **crash-safe**是什么？

在 InnoDB 存储引擎中，事务提交过程中任何阶段，MySQL突然奔溃，重启后都能保证事务的完整性，已提交的数据不会丢失，未提交完整的数据会自动进行回滚

也即MYSQL异常重启之后，能保证数据的一致性

### redolog（重做日志）

也叫事务日志，由InnoDB存储引擎层产生，**记录的是数据库中每个页的修改**，而不是某一行或某几行修改成怎样

redo log就是WAL的典型应用，MySQL在有事务提交对数据进行更改时，只会在内存中修改对应的数据页和记录redo log日志，完成后即表示事务提交成功

![img](https://static001.geekbang.org/resource/image/b0/9c/b075250cad8d9f6c791a52b6a600f69c.jpg)

redo log是固定大小的，所以只能循环写，从头开始写，写到末尾就又回到开头，相当于一个环形

当日志写满了，就需要对旧的记录进行擦除，但在擦除之前，需要确保这些要被擦除记录对应在内存中的数据页都已经刷到磁盘中了

也就是checkpoint到write pos这段记录写到磁盘

**在redo log满了到擦除旧记录腾出新空间这段期间，是不能再接收新的更新请求，所以有可能会导致MySQL卡顿**

==当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存==，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做

### undolog（回滚日志）

提供了回滚的作用，同时也利用这个日志实现MVCC（多个行版本控制）

可以认为当delete一条记录时，undo log中会记录一条对应的insert记录

反之亦然，当update一条记录时，它记录一条对应相反的update记录

### binlog（归档日志）

Server层特有的日志

主要记录用户对数据库操作的SQL语句

binlog不会像redo log一样擦掉之前的记录循环写，而是一直记录（超过有效期才会被清理）

binlog主要用作主从同步和数据库基于时间点的还原

#### 更新SQL语句执行流程中，总共需要写三个日志，是不是都需要能不能简化？

要实现crash-safe必须有redolog和undolog，undolog也是实现可重复读（MVCC）的关键

1. 如果是主从模式下，binlog是必须的，因为从库的数据同步依赖的就是binlog；
2. 如果是单机模式，并且不考虑数据库基于时间点的还原，binlog就不是必须，因为有redo log就可以保证crash-safe能力了；但如果**万一需要回滚到某个时间点的状态**，这时候就无能为力，所以建议binlog还是一直开启

## MYSQL锁机制

### 全局锁

全局锁就是对整个数据库实例加锁

MySQL提供了一个加全局读锁的方法

```mysql
Flush tables with read lock (FTWRL)

unlock tables

#还有一个
set global readonly=true
```

当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

**全局锁的典型使用场景是，做全库逻辑备份**

风险：
1.如果在==主库备份==，在备份期间不能更新，业务停摆
2.如果在==从库备份==，备份期间不能执行主库同步的binlog，导致主从延迟

官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数**–single-transaction**的时候，**导数据之前就会启动一个事务**，来确保拿到一致性视图。而**由于MVCC的支持，这个过程中数据是可以正常更新的**。

你一定在疑惑，有了这个功能，为什么还需要FTWRL呢？**一致性读是好，但前提是引擎要支持这个隔离级别。**比如，对于MyISAM这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用FTWRL命令了。

所以，**single-transaction方法只适用于所有的表使用事务引擎的库。**如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。这往往是DBA要求业务开发人员使用InnoDB替代MyISAM的原因之一

#### **既然要全库只读，为什么不使用set global readonly=true的方式呢**？

- 一是，在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，我不建议你使用。
- 二是，在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态（因为不能更新也不需要什么回滚操作）。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高

### 表级锁

分两种，表锁和元数据锁（MDL）

#### 表锁

**语法**

```mysql
lock tables T1 read/write ,T2 read/write

unlock tables;
```

#### MDL锁

**另一类表级的锁是MDL（metadata lock)。**MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

因此，在MySQL 5.5版本中引入了MDL，**当对一个表做增删改查操作的时候，加MDL读锁**；**当要对表做结构变更操作的时候，加MDL写锁**。

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

当一个读锁被阻塞的时候，后面的读锁也会被堵住，如果客户端有超时重试的话，那么线程很快就会满

**事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放**

#### **那么如何安全地给小表加字段？**

先解决长事务，长事务不提交，就会一直占着MDL锁。在MySQL的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。**如果你要做DDL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务**。

但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？

这时候kill可能未必管用，因为新的请求马上就来了（来了就会又创建事务）。比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法

```
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 
```

### 行锁

MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM被InnoDB替代的重要原因之一

#### 两阶段锁

**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是==两阶段锁协议==**

==如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放==

#### 死锁以及解决方法

当并发系统中不同线程出现**循环资源依赖**，涉及的线程都在**等待别的线程释放资源时**，就会导致这几个线程都进入无限等待的状态

##### 出现死锁后有两种策略：

- 一种策略是，直接**进入等待，直到超时**。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。
- 另一种策略是，发起死锁检测，发现死锁后，**主动回滚死锁链条中的某一个事务**，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。

那如果是我们上面说到的所有事务都要更新同一行的场景呢？

每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的CPU资源。因此，你就会看到CPU利用率很高，但是每秒却执行不了几个事务

#### 怎么解决由这种热点行更新导致的性能问题呢？

**一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以==临时把死锁检测关掉==。**但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。

**另一个思路是==控制并发度==。**根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有600个客户端，这样即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到3000。

因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，对于==相同行的更新，在进入引擎之前排队==。这样在InnoDB内部就不会有大量的死锁检测工作了。

可能你会问，**如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？**

你可以考虑通过==将一行改成逻辑上的多行来减少锁冲突==。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。

这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处理。

mysql InnoDB行锁不使用索引查询的话会锁整张表

#### 死锁产生的必要条件

1. 互斥条件
2. 请求和保持条件  进程至少保持了一个资源，并提出新的资源请求
3. 不可抢占条件  获得的资源不会被抢占
4. 循环等待条件 存在循环链

#### 处理死锁方法

1. 预防死锁
2. 避免死锁  利用银行家算法，提前判断资源是否足够
3. 检测死锁
4. 解除死锁

#### 预防死锁：

1. 破坏请求和保持条件 一次性请求
2. 破坏不可抢占，当一个进程已经持有某些不可抢占资源并提出新的资源请求而不能被满足时，释放保持的资源
3. 破坏循环等待条件

## 事务

### 事务特性

1. 原子性 （atomicity）:强调事务的不可分割.
2. 一致性 （consistency）:事务的执行的前后数据的完整性保持一致.
3. 隔离性 （isolation）:一个事务执行的过程中,不应该受到其他事务的干扰
4. 持久性（durability） :事务一旦结束,数据就持久到数据库

### 并发事务会出现的问题

|            |                             描述                             |
| :--------: | :----------------------------------------------------------: |
|    脏读    |               A事务读到了B事务修改但未提交的值               |
| 不可重复读 |                   A事务重复读两次值不一样                    |
|    幻读    | 事务A查询id=10的记录是否存在，不存在则准备插入，此时事务B插入id=10的记录，A再插入的时候则会报错，此时就发生了幻读 |

幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行

### 隔离级别

|   级别   |     symbol      | 值   |                             描述                             |                           存在问题                           |
| :------: | :-------------: | ---- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 读未提交 |  READ-UNCOMMIT  | 0    |       一个事务还没提交时，它做的变更就能被别的事务看到       |                  存在脏读、不可重复读、幻读                  |
| 读已提交 |   READ-COMMIT   | 1    |         个事务提交之后，它做的变更才会被其他事务看到         |                解决脏读、存在不可重复读、幻读                |
| 可重复读 | REPEATABLE-READ | 2    | 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的 | mysql默认隔离级别，解决脏读、不可重复读，存在幻读，使用MVCC实现可重复读 |
|  序列化  |   SERIALIZALE   | 3    | 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 |      解决脏读、不可重复读、幻读，但完全串行化，性能最低      |

### 事务隔离的实现

![image-20201227184110343](/C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20201227184110343.png)

利用undolog实现MVCC，从而保证事务的可重复读

**高低水位比对规则**

  1.如果row trx_id小于等于低水位落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；

  2.如果row trx_id大于等于高水位落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；

  3.如果落在黄色部分，那就包括两种情况

​    a. 若row trx_id在read view中，表示这个版本是由还没提交的事务生成的，不可见。

​    b. 若row trx_id不在read view中，表示这个版本是已经提交了的事务生成的，可见。

#### 更新的时候用当前读

因此，在更新的时候，当前读拿到的数据是(1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101。

所以，在执行事务B查询语句的时候，一看自己的版本号是101，最新数据的版本号也是101，是自己的更新，可以直接使用，所以查询得到的k的值是3。

#### 回滚日志总不能一直保留吧，什么时候删除呢？

答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。

#### 什么时候才不需要了呢？

就是当系统里没有比这个回滚日志更早的read-view的时候。

#### 为什么不要用长事务呢？

长事务意味着系统里面会存在很老的事务视图（readview）。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库

### 事务启动方式

如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：

1. 显式启动事务语句， **begin** 或 **start transaction**。配套的提交语句是**commit**，回滚语句是**rollback**。
2. **set autocommit=0**，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行**commit** 或 **rollback** 语句，或者断开连接。

### 事务到底是隔离还是不隔离

当事务需要更新数据的时候，读数据用的是当前读，而当前读读的是数据中的最新值

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：

1. 版本未提交，不可见
2. 版本已提交，但是是在视图创建后提交的，不可见
3. 版本已提交，而且是在视图创建前提交的，可见

去看第八章

### 幻读

##### 什么是幻读

1. 在可重复读隔离级别下，普通的查询是**快照读**，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。
2. 事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 称为幻读

幻读仅专指“新插入的行”

##### 产生的问题

1.语义上的

2.数据一致性的问题

造成binlog归档的异常

##### 如何解决幻读？（间隙锁）

现在你知道了，产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。

顾名思义，**间隙锁**，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录，这就产生了7个间隙。

![img](https://static001.geekbang.org/resource/image/e7/61/e7f7ca0d3dab2f48c588d714ee3ac861.png)

。这样就确保了无法再插入新的记录。

也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁

**跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作**

这个同学碰到的现象是，这个逻辑一旦有并发，就会碰到死锁。你一定也觉得奇怪，这个逻辑每次操作前用for update锁起来，已经是最严格的模式了，怎么还会有死锁呢？

这里，我用两个session来模拟并发，并假设N=9

![img](https://static001.geekbang.org/resource/image/df/be/df37bf0bb9f85ea59f0540e24eb6bcbe.png)

你看到了，其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来分析一下：

1. session A 执行select ... for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10);
2. session B 执行select ... for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；
3. session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；
4. session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。

至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。

**间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的**

间隙锁是在可重复读隔离级别下才会生效的

## 索引

有三种数据结构可以实现索引

1. hash  不适用范围查找 适合等值查询
2. 有序数组  适用范围查找，但是插入不方便  是和静态数据的查找
3. 搜索树



### InnoDB 的索引模型

##### B树和B+树的区别

1. B树的每个节点存储了key和data，key是一条数据记录的键值
   ，是唯一的，data存储的是数据记录除key以外的数据。而B+树只在叶子节点存储data数据，这样非叶子节点就能存储更多的key。所以B+树相较于B树来说更加的矮胖，因为索引树很大不能一次IO读取进内存，树的深度越浅，查找数据时IO的次数就越少，效率就更快。
2. B+树的每个叶子节点的指针指向相邻的叶子节点，构成一个有序链表，可以按照关键码排序的次序遍历全部记录。由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树叶子节点指针为null，则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好

**B+树的叶节点之间通过双向链表链接，B树是单向链表**

除了每个节点能存更多值之外，因为双向链表的原因，B+树更适合范围查找

##### 不同引擎中B+树的区别

1. **MyISAM**中，data存的是数据地址。索引是索引，数据是数据。索引放在XX.MYI文件中，数据放在XX.MYD文件中，所以也叫**非聚簇索引**。

2. **InnoDB**中，data存的是数据本身。索引也是数据。数据和索引存在一个XX.IDB文件中，所以也叫**聚簇索引**

### 索引维护

B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为**页分裂**。在这种情况下，性能自然会受影响。

除了性能外，页分裂操作还**影响数据页的利用率**。原本放在一个页的数据，现在分到两个页中，**整体空间利用率降低大约50%**。

当然有分裂就有合并。当**相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并**。合并的过程，可以认为是分裂过程的逆过程。

### 索引类型

#### **主键索引**（聚集索引）

叶子节点存储主键与数据

#### **二级索引**（非聚集索引）

叶子节点存主键，因为在查找数据的时候可能会有**回表**操作

同时二级索引分为以下几种

1. **唯一索引(Unique Key)** ：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
2. **普通索引(Index)** ：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**
3. **前缀索引(Prefix)** ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。
4. **全文索引(Full Text)** ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。

前缀索引中，取字符串的长度时需要注意**区分度**，区分度高的作为索引时才能减少

看下面例子

**怎么给字符串字段加索引**

这两个在email字段上创建索引的语句：

```
mysql> alter table SUser add index index1(email);
或
mysql> alter table SUser add index index2(email(6));
```

接下来，我们再看看下面这个语句，在这两个索引定义下分别是怎么执行的。

```
select id,name,email from SUser where email='zhangssxyz@xxx.com';
```

**如果使用的是index1**（即email整个字符串的索引结构），执行顺序是这样的：

1. 从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得ID2的值；
2. 到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；
3. 取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email='zhangssxyz@xxx.com’的条件了，循环结束。

这个过程中，**只需要回主键索引取一次数据，所以系统认为只扫描了一行**。

**如果使用的是index2**（即email(6)索引结构），执行顺序是这样的：

1. 从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；
2. 到主键上查到主键值是ID1的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢弃；
3. 取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；
4. 重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。

在这个过程中，**要回主键索引取4次数据，也就是扫描了4行**。

通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多

**同时前缀索引还会对覆盖索引产生影响**

**前缀索引对覆盖索引的影响**：

看看这个SQL语句：

```
select id,email from SUser where email='zhangssxyz@xxx.com';
```

当用前缀索引的时候就不得不再回表判断是否真的相等

#### 聚集索引的缺点

1. **依赖于有序的数据** ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
2. **更新代价大** ： 如果对**索引列的数据被修改时，那么对应的索引也将会被修改**， 而且况聚集索引的叶子节点还存**放着数据**，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的

#### 非聚集索引缺点

1. 跟聚集索引一样，非聚集索引也依赖于有序的数据
2. **可能会二次查询(回表)** :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询

#### 覆盖索引

**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询**

> 如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。
>
> 再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表

#### 最左前缀原则

==**这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符**==。

**如果建的索引是 (name, cid)。而查询的语句是 cid=1 AND name=’小红’。为什么还能利用到索引？**

当按照索引中所有列进行精确匹配（“=” 或 “IN”）时，索引可以被用到，并且 type 为 const。理论上索引对顺序是敏感的，但是由于 MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，所以 MySQL 不存在 where 子句的顺序问题而造成索引失效

##### 最左索引注意事项

1. 范围查询
   mysql 会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配。范围列可以用到索引，但是范围列后面的列无法用到索引。即，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引
2. like 语句的索引问题
   如果通配符 % 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀
   在 like “value%” 可以使用索引，但是 like “%value%” 不会使用索引，走的是全表扫描
3. 不要在列上进行运算
   如果查询条件中含有函数或表达式，将导致索引失效而进行全表扫描
   例如 select * from user where **YEAR** **(**birthday**)** < 1990
   可以改造成 select * from users where birthday <’1990-01-01′
4. 索引不会包含有 NULL 值的列
   只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。所以在数据库设计时不要让字段的默认值为 NULL
5. 尽量选择区分度高的列作为索引，区分度的公式是 count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0。一般需要 join 的字段都要求区分度 0.1 以上，即平均 1 条扫描 10 条记录
6. 覆盖索引的好处
   如果一个索引包含所有需要的查询的字段的值，我们称之为覆盖索引。覆盖索引是非常有用的工具，能够极大的提高性能。因为，只需要读取索引，而无需读表，极大减少数据访问量

**例子**

**多列索引在and查询中应用**

```mysql
select * from test where a=? and b=? and c=?；查询效率最高，索引全覆盖。

select * from test where a=? and b=?；索引覆盖a和b。

select * from test where b=? and a=?；经过mysql的查询分析器的优化，索引覆盖a和b。

select * from test where a=?；索引覆盖a。

select * from test where b=? and c=?；没有a列，不走索引，索引失效。

select * from test where c=?；没有a列，不走索引，索引失效。
```

**多列索引在范围查询中应用**

```mysql
select * from test where a=? and b between ? and ? and c=?；索引覆盖a和b，因b列是范围查询，因此c列不能走索引。

select * from test where a between ? and ? and b=?；a列走索引，因a列是范围查询，因此b列是无法使用索引。

select * from test where a between ? and ? and b between ? and ? and c=?；a列走索引，因a列是范围查询，b列是范围查询也不能使用索引。
```

**多列索引在排序中应用**

```mysql
select * from test where a=? and b=? order by c；a、b、c三列全覆盖索引，查询效率最高。

select * from test where a=? and b between ? and ? order by c；a、b列使用索引查找，因b列是范围查询，因此c列不能使用索引，会出现file sort。
```

某个字段走范围查询那么另一个字段就不走索引

#### 索引下推

```
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```

在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。

而MySQL 5.6 引入的==索引下推==优化（index condition pushdown)， 可以在索引遍历过程中，**对索引中包含的字段先做判断**(也就是不先like)，直接过滤掉不满足条件的记录，减少回表次数。

#### 唯一索引和普通索引

唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率

#### 唯一索引和普通索引查询过程区别（知道唯一索引的缺点）

- 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。
- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

在InnoDB中，每个数据页的大小默认是16KB

##### change buffer

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性

虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上

将change buffer中的操作应用到原数据页，得到最新结果的过程称为==**merge**==。除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。

##### **什么条件下可以使用change buffer呢？**

唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。

因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用

##### **如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的**

第一种情况是，**这个记录要更新的目标页在内存中**。这时，InnoDB的处理流程如下：

- 对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。

这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。

但，这不是我们关注的重点。

第二种情况是，**这个记录要更新的目标页不在内存中**。这时，InnoDB的处理流程如下：

- 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。

将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。

之前我就碰到过一件事儿，有个DBA的同学跟我反馈说，他负责的某个业务的库内存命中率突然从99%降低到了75%，整个系统处于阻塞状态，更新语句全部堵住。而探究其原因后，我发现这个业务有大量插入数据的操作，而他在前一天把其中的某个普通索引改成了唯一索引

##### change buffer的使用场景

通过上面的分析，你已经清楚了使用change buffer对更新过程的加速作用，也清楚了change buffer只限于用在普通索引的场景下，而不适用于唯一索引。那么，现在有一个问题就是：普通索引的所有场景，使用change buffer都可以起到加速作用吗？

因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。

因此，对于**写多读少**的业务来说，**页面在写完以后马上被访问到的概率比较小**，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。

反过来，假设一个业务的更新模式是**写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程**。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。

**如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭change buffer**

## MyISAM和InnoDB存储引擎的区别

1. **InnoDB 支持事务，MyISAM 不支持事务。**这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

2. **InnoDB 支持外键，而MyISAM 不支持外键。**对一个包含外键的 InnoDB 表转为 MYISAM 会失败；

3. **InnoDB 是聚集索引，MyISAM 是非聚集索引。**聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 **MyISAM** 是非聚集索引，数据文件是分离的，索引保存的是**数据文件的指针**。主键索引和辅助索引是独立的。

4. **InnoDB 不保存表的具体行数**，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；

5. **InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。**一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

## 乐观锁和悲观锁

### 悲观锁(Pessimistic Lock)

 当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制

1. 传统的关系型数据库使用这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。
2. Java 里面的同步 [synchronized](https://www.jianshu.com/p/c8f997e7f75c) 关键字的实现

悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据

### 乐观锁(Optimistic Locking)

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量

CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。

版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功

### 悲观锁的实现

要使用悲观锁，必须关闭 [MySQL](https://www.jianshu.com/p/359c3fe50c7f) 数据库的自动提交属性`set autocommit=0`。因为 MySQL 默认使用 autocommit 模式，也就是说，当执行一个更新操作后，MySQL 会立刻将结果进行提交。

以电商下单扣减库存的过程说明一下悲观锁的使用：

![img](https://upload-images.jianshu.io/upload_images/7038163-6cc15e52ffa4f893.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/503/format/webp)

在对 id = 1 的记录修改前，先通过 [for update](https://www.jianshu.com/p/6ecc0d21dc50) 的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。

如果发生并发，同一时间只有一个线程可以开启事务并获得 id=1 的锁，其它的事务必须等本次事务提交之后才能执行。这样可以保证当前的数据不会被其它事务修改。

使用 [select…for update](https://www.jianshu.com/p/6ecc0d21dc50) 锁数据，需要注意锁的级别，MySQL InnoDB 默认行级锁。行级锁都是基于索引的，**如果一条 SQL 语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住**，这点需要注意

### 乐观锁的实现

当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。比如前面的扣减库存问题，通过乐观锁可以实现如下：

![img](https://upload-images.jianshu.io/upload_images/7038163-623702054ade5d92.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/490/format/webp)

在更新之前，先查询一下库存表中当前库存数(quantity)，然后在做 update 的时候，以库存数作为一个修改条件。当提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据

但是会存在ABA问题（和之前的CAS一样）

一个比较好的解决办法，就是通过一个单独的可以顺序递增的 version 字段。优化如下

![img](https://upload-images.jianshu.io/upload_images/7038163-a23fb455b893f97f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

乐观锁每次在执行数据修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行 +1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性

```mysql
update t_goods   
set status=2, version = version + 1  
where id=#{id} and version = #{version};
```



# Java集合

## ArrayList

### 1.7

![image-20210605124248205](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210605124248205.png)

### 1.8

elementData初始化为{}，并没有实例化，第一次add的时候才创建了数组

## Map

**HashMap** 可以存储null的key-value

**Hashtable** 不可以存null

**TreeMap**

![image-20210605170341034](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210605170341034.png)

![image-20210605185803886](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210605185803886.png)

### 1.7

new HashMap（）创建一个默认长度为**16**，负载因子为**0.75**的Entry[]数组，添加元素的时候分三种情况

1. 看hash得到的index位置是否为空，为空直接放
2. 不为空，判断对应位置对象与当前对象的equal结果如果为false，不一样，继续添加
3. 为true，一样，替换value值

当**（临界值threshold）长度>=size*loadFactor**（且要存放的位置非空的时候）进行扩容操作，resize到原来的两倍且会进行rehash

7上8下，7的时候新的结点是直接占据数组所在的位置

hash方法中会用到hashcode   真正的位置还需要经过index····方法

头插法，会产生环

### 1.8

尾插法并发不会产生环了

new Hashmap（）没有直接创建数组，只是赋值了默认的负载因子，也是第一次put的时候才进行扩容和arrayList一样

Enrty数组变成Node数组

链表长度大于8（且容量大于等于64）才进行红黑树转换

如果长度大于8但是容量小于64则进行扩容

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)//初始化
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)//判断通过hash得到对应位置上是否有值
            tab[i] = newNode(hash, key, value, null);
        else {
            //有的话  再判断一次hash值是否一样，如果是一样的话继续判断key引用是否一样或者用equal判断key的情况(相同覆盖，不同			  //添加)
            //如果hash不一样则说明可以继续到后面判断链表或者树中的对象是否相等 (hash通过某种运算后得到的位置可能一样)
            Node<K,V> e; K k;
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
```

初始化能保证容量为2的n次方

### **HashMap中初始容量的合理值**

通过上面的分析我们可以知道，当我们使用HashMap(int initialCapacity)来初始化容量的时候，JDK会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？

```text
initialCapacity = (需要存储的元素个数 / 负载因子) + 1
```

这里的负载因子就是loaderFactor，默认值为0.75。

```text
initialCapacity = expectedSize / 0.75F + 1.0F
```

上面这个公式是《阿里巴巴Java开发手册》中的一个建议，在Guava中也是提供了相同的算法，更甚之，这个算法实际上是JDK8中putAll()方法的实现。这是公式的得出是因为，当HashMap内部维护的哈希表的容量达到75%时（默认情况下），就会触发rehash（重建hash表）操作。而rehash的过程是比较耗费时间的。所以初始化容量要设置成expectedSize/0.75 + 1的话，可以有效地减少冲突，也可以减小误差。

### 高并发下可能出现的问题

**多线程put的时候可能导致元素丢失**
HashMap另外一个并发可能出现的问题是，可能产生元素丢失的现象。

考虑在多线程下put操作时，执行addEntry(hash, key, value, i)，如果有产生哈希碰撞

导致两个线程得到同样的bucketIndex去存储，就可能会出现覆盖丢失的情况：



当多线程同时put值的时候，若发生hash碰撞，可能多个元素都落在链表的头部，从而造成元素覆盖（hashcode相同而eques值不同的元素）

列如：线程A put一个元素a ，线程B put一个元素b，a,b 发生hansh碰撞，本应该在map是链表的形式存在，但是可能线程A和线程B同时put到链表的第一个位置，从而后来者覆盖前者元素造成元素丢失。


## ConcurrentHashMap

空参构造函数不做任何操作，默认长度也是16

传参数大小问题，如果传长度32实际长度会为64

```java
public ConcurrentHashMap(int initialCapacity) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException();
        int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
                   MAXIMUM_CAPACITY :
                   tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));//这里传过去的值是n+n/2+1
        this.sizeCtl = cap;
    }
```



```java
  private static final int tableSizeFor(int c) {
      //计算出比大的最小的2的n次方的数
        int n = c - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```

不允许null的key和value

### 1.7

大致数据结构

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIPf1sDCN5zcDdGsibZwyzy9rmnTSzibQ6VEBXUhicBWHFae47ShkNzCRB7SZibuUN6gDmGkfeB5saAMQQ/640?wx_fmt=png)

仍然是由数组+链表构成

segment继承可重入锁

#### put方法

```java
 1    public V put(K key, V value) {
 2        Segment<K,V> s;
 3        if (value == null)
 4            throw new NullPointerException();
 5        int hash = hash(key);
 6        int j = (hash >>> segmentShift) & segmentMask;//获取段的位置
 7        if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck
 8             (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment
 9            s = ensureSegment(j);
10        return s.put(key, hash, value, false);
11    }
```

获取到段之后调用具体的**put**方法

```java
 1        final V put(K key, int hash, V value, boolean onlyIfAbsent) {
 2            HashEntry<K,V> node = tryLock() ? null ://tryLock也是尝试获取锁但是不阻塞，立即返回true或者false
 3                scanAndLockForPut(key, hash, value);//这个方法里面自旋进行获取锁
 4            V oldValue;
 5            try {
 6                HashEntry<K,V>[] tab = table;//将当前segment对象的hashentry
 7                int index = (tab.length - 1) & hash;//具体hashentry中的索引
 8                HashEntry<K,V> first = entryAt(tab, index);//获取到对应的桶值
 9                for (HashEntry<K,V> e = first;;) {
10                    if (e != null) {
11                        K k;
12                        if ((k = e.key) == key ||
13                            (e.hash == hash && key.equals(k))) {//判断hash key  keyequals是否相等 相等覆盖退出
14                            oldValue = e.value;
15                            if (!onlyIfAbsent) {
16                                e.value = value;
17                                ++modCount;
18                            }
19                            break;
20                        }
21                        e = e.next;//上面不相等则一直遍历链表
22                    }
23                    else {
24                        if (node != null)
25                            node.setNext(first);
26                        else
27                            node = new HashEntry<K,V>(hash, key, value, first);//创建新的hashentry
28                        int c = count + 1;
29                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)//扩容
30                            rehash(node);
31                        else
32                            setEntryAt(tab, index, node);
33                        ++modCount;
34                        count = c;
35                        oldValue = null;
36                        break;
37                    }
38                }
39            } finally {
40                unlock();
41            }
42            return oldValue;
43        }
```

首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 `scanAndLockForPut()` 自旋获取锁

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIPf1sDCN5zcDdGsibZwyzy9r9Zlk8CZt9Bq2GUFa4fR7dINAciazXctxwMLZP23KEnEsXibUUBjeh2rw/640?wx_fmt=png)

当次数超过**MAX_SCAN_RETRIES**(64)，则用阻塞锁获取

获取到锁之后

1. 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。
2. 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。
3. 为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。
4. 最后会解除在 1 中所获取当前 Segment 的锁

统一流程：

1. 通过hash定位segment的位置，然后调用对应的put方法  segment本身继承reentranlock
2. 尝试获取锁，失败进入自旋 最大自旋64次依旧没成功则阻塞
3. 获取到锁 通过hash&(n-1)获取hashentry位置
4. 遍历这个hashEntry  同时进行hash和equls判断
5. 如果最后遍历完或者本来就为空 则new一个插入到链表尾部
6. 最后unlock

#### get方法

get 逻辑比较简单：

只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。

由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。

ConcurrentHashMap 的 get 方法是非常高效的，**因为整个过程都不需要加锁**。

1.7的问题依旧是链表过长导致的查询效率过低问题，所以1.8引入了红黑树

### 1.8

抛弃了原有的segment，采用CAS+synchronized

hashEntry变成了Node

#### put方法

①先传入一个k和v的键值对，不可为空（HashMap是可以为空的），如果为空就直接报错。
②接着去判断table是否为空，如果为空就进入初始化阶段。
③如果判断数组中某个指定的桶是空的，那就直接把键值对插入到这个桶中作为头节点，而且这个操作不用加锁（CAS）。
④如果这个要插入的桶中的hash值为-1，也就是MOVED状态（也就是这个节点是forwordingNode），那就是说明有线程正在进行扩容操作，那么当前线程就进入协助扩容阶段。
⑤需要把数据插入到链表或者树中，如果这个节点是一个链表节点，那么就遍历这个链表，如果发现有相同的key值就更新value值，如果遍历完了都没有发现相同的key值，就需要在链表的尾部插入该数据。插入结束之后判断该链表节点个数是否大于8，如果大于就需要把链表转化为红黑树存储。
⑥如果这个节点是一个红黑树节点，那就需要按照树的插入规则进行插入。
⑦put结束之后，需要给map已存储的数量+1，在addCount方法中判断是否需要扩容

#### get方法

```java
//会发现源码中没有一处加了锁
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    int h = spread(key.hashCode()); //计算hash
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {//读取首节点的Node元素
        if ((eh = e.hash) == h) { //如果该节点就是首节点就返回
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                return e.val;
        }
        //hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来
        //eh=-1，说明该节点是一个ForwardingNode，正在迁移，此时调用ForwardingNode的find方法去nextTable里找。
        //eh=-2，说明该节点是一个TreeBin，此时调用TreeBin的find方法遍历红黑树，由于红黑树有可能正在旋转变色，所以find里会有读写锁。
        //eh>=0，说明该节点下挂的是一个链表，直接遍历该链表即可。
        else if (eh < 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        while ((e = e.next) != null) {//既不是首节点也不是ForwardingNode，那就往下遍历
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```



### ConcurrentHashMap 的 get 方法为什么不用加锁，会不会出现数据读写不一致情况呢？

添加了volatile，保证了可见性

### 为什么 ConcurrentHashMap 的 key 和 value 不能为 null？

首先，只有put了null的时候containskey才返回true，否则返回false

```java
 HashMap<String, String> hashMap = new HashMap<String, String>() {{
            //put(null, null);
        }};
        System.out.println(hashMap.containsKey(null));
```

所以hashmap在单线程下，当get（key）==null的时候，可以通过containskey来判断

1. 这个key从来没有在map中映射过

2. 2.这个key的value在设置的时候，就是null

也就是说如果原本对应的key是存在的话，就会返回true

但是如果是在并发场景下，假设线程A，B

如果A想验证get(key)==null是为什么（假设就是因为key不存在）

当A get完之后，B 进行put(key,null)

这个时候再containskey就会返回true，此时语义上就出现的问题

### 说下 ConcurrentHashMap 的 put 方法执行逻辑。

JDK1.7：

先尝试自旋获取锁，如果自旋重试的次数超过 64 次，则改为阻塞获取锁。获取到锁后：

1. 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。
2. 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。
3. 为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。
4. 释放 Segment 的锁

JDK1.8：

没初始化先初始化

hash算位置

先定位到 Node，拿到首节点 first，判断是否为：

1. 如果为 null ，通过 CAS 的方式把数据 put 进去。
2. 如果不为 null ，并且 first.hash = MOVED = -1 ，说明其他线程在扩容，参与一起扩容。
3. 如果不为 null ，并且 first.hash != -1 ，synchronized 锁住 first 节点，判断是链表还是红黑树，遍历插入。

### 初始化

根据sizectl

<0 让出cpu

否则 cas修改sizectl成-1 进行初始化并且在最后将sizectl修改成阈值

单线程新建nextTable，新容量一般为原table容量的两倍。
每个线程想增/删元素时，如果访问的桶是ForwardingNode节点，则表明当前正处于扩容状态，协助一起扩容完成后再完成相应的数据更改操作。
扩容时将原table的所有桶倒序分配，每个线程每次最小分配16个桶，防止资源竞争导致的效率下降。单个桶内元素的迁移是加锁的，但桶范围处理分配可以多线程，在没有迁移完成所有桶之前每个线程需要重复获取迁移桶范围，直至所有桶迁移完成

### 什么时候会扩容？

当往hashMap中成功插入一个key/value节点时，有两种情况可能触发扩容动作：
1、**如果新增节点之后，所在链表的元素个数达到了阈值 8，则会调用treeifyBin方法把链表转换成红黑树**，不过在结构转换之前，会对数组长度进行判断，实现如下：如果数组长度n小于阈值MIN_TREEIFY_CAPACITY，默认是64，则会调用tryPresize方法把数组长度扩大到原来的两倍，并触发transfer方法，重新调整节点的位置。

2、**调用put方法新增节点时**，在结尾会调用**addCount**方法记录元素个数，并检查是否需要进行扩容，当数组元素个数达到阈值时，会触发transfer方法，重新调整节点的位置。

扩容状态下其他线程对集合进行插入、修改、删除、合并、compute 等操作时遇到 ForwardingNode 节点会触发扩容 。


### 在扩容时读写操作如何进行

(1)对于get读操作，如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。

如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时get线程会帮助扩容。

(2)对于put/remove写操作，如果当前链表已经迁移完成，那么头节点会被设置成fwd节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。

### 扩容时get操作

会有一个判断hash是不是小于0

-1位fwt节点   调用node.find()方法，直接去nextTable里面找   这个nexttable实际上就是迁移好的那一部分

-2为红黑树节点  调用红黑树的find.() 里面有锁，因为有可能在变色

### 关于concurrenthashmap的问题

https://blog.csdn.net/zzu_seu/article/details/106698150

# 单例模式

构造器私有

##  饿汉式

```java
public class ImageLoader{ 
     private static ImageLoader instance = new ImageLoader(); 
     private ImageLoader(){} 
     public static ImageLoader getInstance(){  
          return instance;  
      } 
}
```

一上来就把对象创建了

**存在的问题**：对象还没有用到的时候就创建了，造成了资源的浪费

## DCL（双端检索懒汉式）

```java
public class SingletonLearn {
    private volatile static SingletonLearn singletonLearn;
    public static SingletonLearn getInstance(){
        if (singletonLearn==null){//这个判断避免以后再进行同步锁住类
            synchronized (SingletonLearn.class){
                if (singletonLearn==null)
                singletonLearn=new SingletonLearn();
            }

        }
        return singletonLearn;
    }
}
```

## 静态内部实现类

```java
/**
 * 静态内部类实现单例模式
 */
public class Singleton {
    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }

    /**
     * 静态内部类
     */
    private static class SingletonHolder {
        private static Singleton instance = new Singleton();
    }
}
```

第一次加载Singleton类时不会初始化instance，只有在第一次调用getInstance()方法时，**虚拟机会加载SingletonHolder类**，初始化instance。

这种方式既保证线程安全，单例对象的唯一，也延迟了单例的初始化，**推荐使用这种方式来实现单例模式**

## 通过反射/序列化破坏单例模式

**反射破坏**

```java
Constructor<SingletonLearn> declaredConstructor = SingletonLearn.class.getDeclaredConstructor(null);
declaredConstructor.setAccessible(true);//允许调用私有构造好数
declaredConstructor.newInstance();
```

```java
可以在无参构造函数里面再加一个判断
public SingletonLearn() {
        System.out.println("heihei");
        synchronized (SingletonLearn.class){
            if (singletonLearn!=null)
                throw new RuntimeException("不要破坏单例模式");
        }
    }
```

但是如果**两个对象**都是反射new出来的就没办法解决

**序列化破坏**

```java
 Singleton instance = Singleton.getInstance();
        byte[] serialize = SerializationUtils.serialize(instance);
        Singleton newInstance = SerializationUtils.deserialize(serialize);
        System.out.println(instance == newInstance);
```



## 枚举实现

```java
public enum SingleTon {
    SINGLE;
    public SingleTon getInsatnce(){
        return SINGLE;
    }
}
```

防止了反射以及序列化的破坏

# 红黑树

## 特性

**（1）每个节点或者是黑色，或者是红色。**
**（2）根节点是黑色。**
**（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
**（4）如果一个节点是红色的，则它的子节点必须是黑色的。**
**（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

## 操作

**左旋**：以某个结点作为支点(旋转结点)，其**右子结点**变为旋转结点的**父结点**，**右**子结点的**左**子结点变为**旋转结点的右子**结点，左子结点保持不变。如图3。

**右旋**：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。

**变色**：结点的颜色由红变黑或由黑变红



![img](https://upload-images.jianshu.io/upload_images/2392382-a95db442f1b47f8a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://upload-images.jianshu.io/upload_images/2392382-0676a8e2a12e2a0b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

## 插入

插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大

节点插入的时候应该插入红色节点，因为本身是黑色平衡

从根结点开始查找；

若根结点为空，那么插入结点作为根结点，结束。

若根结点不为空，那么把根结点作为当前结点；

若当前结点为null，返回当前结点的父结点，结束。

若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。

若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；

若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；

## 效率

O（log（n))

# 二叉树性质

n0=n2+1

# 如何保证CA证书的合法性

https://mp.weixin.qq.com/s/2_iPy3-qh_VuzBCLtOFGxQetu
