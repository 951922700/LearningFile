# 查询语句不使用select *原因？

1，数据库**需要知道 * 等于什么** = 查数据字典会增大开销（记录数据库和应用程序元数据的目录）
 2，多出一些不用的列，这些列可能正好不在索引的范围之内（索引的好处不多说）**select * 杜绝了索引覆盖**的可能性，而索引覆盖又是速度极快，效率极高，业界极为推荐的查询方式。
 3，不需要的字段会增加数据传输的时间，即使 mysql 服务器和客户端是在同一台机器上，使用的协议还是 tcp，通信也是需要额外的时间。
 4，大字段，例如很长的 varchar，blob，text。准确来说，长度超过 728 字节的时候，会把超出的数据放到另外一个地方，因此读取这条记录会增加一次 io 操作。----mysql innodb
 5，影响数据库自动重写优化SQL（类似 Java 中编译 class 时的编译器自动优化） 。----Oracle
 6，select * 数据库需要解析更多的 对象，字段，权限，属性相关，在 SQL 语句复杂，硬解析较多的情况下，会对数据库造成沉重的负担
 7，额外的 io，内存和 cpu 的消耗，因为多取了不必要的列。
 8，用 SELECT * 需谨慎，因为一旦列的个数或顺序更改，就有可能程序执行失败。

# drop、truncate、delete的区别

1. DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。

     TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

2. 当表被**TRUNCATE** 后，这个表和索引所占用的空间会恢复到初始大小，

     **DELETE**操作不会减少表或索引所占用的空间。

     **drop**语句将表所占用的空间全释放掉。

3. truncate 不能触发任何Delete触发器。

4. delete 删除可以返回行数

# char和varchar

1. 首先明确的是，==char的长度是不可变的，而varchar的长度是可变的==，也就是说，定义一个char[10]和varchar[10],如果存进去的是‘csdn’,那么==char所占的长度依然为10==，除了字符‘csdn’外，后面跟六个空格，而==varchar就立马把长度变为4了==（还有一位纪录长度），取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。
2. 尽管如此，==char的存取速度还是要比varchar要快得多==，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。
3. ==varchar另加一个字节==来记录长度

# 存储过程

```mysql
create procedure test2()
begin
  -- 使用 declare语句声明一个变量
  declare username varchar(32) default '';
  -- 使用set语句给变量赋值
  set username='xiaoxiao';
  -- 将users表中id=1的名称赋值给username
  select name into username from users where id=1;
  -- 返回变量
  select username;
end;
```

# limit与offset用法

```mysql
以下的两种方式均表示取2,3,4三条条数据。
1.select* from test LIMIT 1,3;
当limit后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量。

2.select * from test LIMIT 3 OFFSET 1;(在mysql 5以后支持这种写法)
当 limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的的数量,offset表示要跳过的数量 。
```

# 自增主键的策略

不同的存储引擎保存自增值的策略不一样；

a. 对于MyISAM引擎，自增值保存在数据文件中；

b. Innodb引擎，mysql5.7之前，自增值保存在内存中，而且不会持久化自增值。每次重启后第一次打开表，都会去查找自增值的最大值max(id), 并设置表当前自增值为max(id) + 1; mysql8.0, 自增值变更记录在了redo log中，重启时依靠redo log恢复重启之前的值。


自增值大于max的话是可以直接设置的，不写的话默认最大值+1，小于的话会判断key是否存在

# 一个innodb表没有主键，他还会有聚集索引嘛？

既然InnoDB对数据的存储必须依赖于主键，那么对于没有创建主键的表，该怎么办？

InnoDB对聚簇索引处理如下： - 如果定义了主键，那么InnoDB会使用主键作为聚簇索引 - 如果没有定义主键，那么**会使用第一非空的唯一索引**（NOT NULL and UNIQUE INDEX）作为**聚簇索引** - 如果既没有主键也找不到合适的非空索引，那么InnoDB会自动生成一个不可见的名为**ROW_ID**的列名为GEN_CLUST_INDEX的**聚簇索引**，该列是一个6字节的自增数值，随着插入而自增

很明显，缺少主键的表，InnoDB会内置一列用于聚簇索引来组织数据。而**没有建立主键的话就没法通过主键来进行索引**，**查询的时候都是全表扫描**，小数据量没问题，大数据量就会出现性能问题。

但是，问题真的只是查询影响吗？

不是的，对于生成的ROW_ID，其自增的实现来源于一个全局的序列，而所有有ROW_ID的表共享该序列，这也意味着插入的时候需要共享一个序列，那么高并发插入的时候为了保持唯一性就避免不了**锁的竞争**，进而影响性能

### 缺少主键或者非空索引存在问题

- 使用不了主键索引，查询会进行全表扫描
- 影响数据插入性能，插入数据需要生成ROW_ID，而生成的ROW_ID是全局共享的，并发会导致锁竞争，影响性能
